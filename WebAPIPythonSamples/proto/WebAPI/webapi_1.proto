syntax = "proto2";

// CQG Web API server protocol

package WebAPI_1;

import "common/decimal.proto";
import "common/shared_1.proto";
import "common/timestamp.proto";
import "WebAPI/rules_1.proto";
import "WebAPI/metadata_1.proto";

// Last changes were made on 20 Dec 2019
// Version 1.134 - (version number is constructed as 'MAJOR.MINOR' from the following enums)

enum ProtocolVersionMajor
{
   // Major number change is required for backward incompatible protocol versions (new 'proto' file is necessary)
   PROTOCOL_VERSION_MAJOR = 1;
}

enum ProtocolVersionMinor
{
   // Minor number is increased for backward compatible protocol versions when new messages and/ or fields are
   // added without removing/ changing any existing messages and fields (new 'proto' file is not created)
   PROTOCOL_VERSION_MINOR = 134;
}

// Protocol rules:
// 1)  CamelCase with an initial capital is used for message names while fields are lowercase underscore_separated_names
//     (see https://developers.google.com/protocol-buffers/docs/style)
// 3)  Key numbers for existing fields must stay the same between minor protocol version changes.
// 4)  Negative values for enums and key numbers are prohibited.
// 5)  Only explicit signed (e.g. sint32) and unsigned (e.g. uint64) integer types must be used. Usage of implicit signed integer
//     types (e.g. int16) is prohibited since they are not supported by JS client library and consume a lot of space for
//     negative values.
// 6)  Unsigned types should be used for fields that cannot have negative values. This allows to minimize their size.
// 7)  Field numbers < 16 takes one byte for a key/ wire-type header so numbers > 16 should be used for optional and infrequently used fields.
//     do not 'reserve' field numbers without real reasons.
//     See https://developers.google.com/protocol-buffers/docs/encoding for details.
// 8)  Field numbers don't always come in a strict order and so allow to place new fields next to logically related ones.
// 9)  'Result' suffix is used in responses when only a single response is possible.
// 10)  'Status' suffix is used a separate message for a status of a subscription when subscriptions are not optional.
// 11) 'Report' suffix is used in responses when 'Result' and 'Data' are combined in a single message and when subscription is optional,
//     this allows to avoid two messages if subscription is not requested.
// 12) Time attributes that are 64-bit signed integers contain offset in milliseconds from base_time attribute of the logon and
//     session restore/join results.
// 13) Client implementation must be ready to get new values of any field associated with enum specified in this protocol
//     (all these fields are made uint32 to make protocol backward compatible for such changes). So when client gets unknown value it should
//     either ignore it or check whether it relates to failure (e.g. whether it's > 100 for StatusCode/ResultCode fields).
// 14) Commodity volumes (or quantities) are specified in one of two forms: cqg.Decimal or uint64. A uint64 volume always means a number of
//     ContractMetadata.volume_scale units. Correct volume is calculated as 'volume' * 'ContractMetadata.volume_scale' in this case.
// 15) If a message - client or server - has two fields for the same volume (quantity): an old uint32 and a new cqg.Decimal,
//     the latter must be used. Old volume fields are left only for compatibility with clients using the protocol before
//     cqg.Decimals volumes introduction.
// 16) Avoid usage of commonly used keywords in message field names.

// Client to Server message, must include at least one field.
// Logon, LogonRoutineClient, RestoreOrJoinSession or ObtainDemoCredentials are required to be the first and the only message after connection.
// Client messages rate is limited, 1000 messages per 10 seconds by default.
// If this rate is exceeded then a user message is sent with details and the connection is closed.
// NOTE: This and other limits mentioned in this protocol are not guaranteed, they are given for reference only
// and are subject to change without prior notice.
message ClientMsg
{
   // Session level messages from client.
   optional Logon logon = 100;
   optional RestoreOrJoinSession restore_or_join_session = 101;
   optional Logoff logoff = 102;
   optional PasswordChange password_change = 103;
   optional ObtainDemoCredentials obtain_demo_credentials = 104;
   optional UserSessionStateRequest user_session_state_request = 105;
   optional Ping ping = 107;
   optional Pong pong = 108;
   optional LogonRoutineClient logon_routine_client = 109;
   optional PasswordChangeRoutineClient password_change_routine_client = 110;

   // Requests for different information with optional subscription for updates.
   // There are the following limits for information requests:
   // 1) Information requests rate is limited, 1000 requests per 100 seconds by default.
   // 2) Number of simultaneous information subscriptions is limited, a separate limit per information request type is used.
   // 3) Number of overall information requests per session is limited, a separate limit per information request type is used.
   repeated InformationRequest information_request = 1;

   // Trade routing subscriptions from client.
   // There are the following limits for trade routing subscriptions:
   // 1) Number of simultaneous subscriptions is limited, 200 by default.
   // 2) Total number of either explicitly or implicitly subscribed accounts is limited, 5000 by default.
   //    Any subscription that leads to exceeding this limit is failed.
   repeated TradeSubscription trade_subscription = 2;

   // Order requests.
   // Requests rate is limited, 300 orders per 10 seconds per account by default.
   repeated OrderRequest order_request = 3;

   // Market data subscriptions from client.
   // Subscriptions number is limited, 200 simultaneous subscriptions by default.
   // Subscriptions on options strikes (puts and calls) of the same option maturity are considered as a single subscription within the limit.
   repeated MarketDataSubscription market_data_subscription = 4;

   // Requests for manipulations with user attributes (linked to the user and client_app_id).
   // There are the following limits for user attributes:
   //  1) storage space is limited, 100 KB by default for a user/client_app_id pair;
   //  2) requests rate is limited, 10 requests per 100 seconds by default.
   repeated ReadUserAttributeRequest read_user_attribute_request = 5;
   repeated ModifyUserAttributeRequest modify_user_attribute_request = 6;

   // Historical data requests.
   // Number of simultaneous historical requests in processing is limited, 10 by default (all types of historical requests together).
   // Number of simultaneous historical requests with subscription for updates is limited, 50 by default (all types of historical requests together).
   repeated TimeAndSalesRequest time_and_sales_request = 7;
   repeated TimeBarRequest time_bar_request = 8;
   repeated VolumeProfileRequest volume_profile_request = 9;
   repeated NonTimedBarRequest non_timed_bar_request = 14;

   // Rules requests.
   // Number of simultaneous defined rules is limited, 100 by default.
   repeated rules_1.RuleRequest rule_request = 10;

   // Messages for accounts that require separate authorization process.
   repeated AccountLogon account_logon = 11;
   repeated AccountPasswordChange account_password_change = 12;
   repeated AccountLogoff account_logoff = 13;

   // Meta-data related request is an administrative message to manipulate
   // Security and instrument settings.
   // It requires a special permission.
   // Requests rate is limited, 100 requests per 100 seconds by default.
   repeated metadata_1.MetadataAdminRequest metadata_admin_request = 15;
}

// Server to Client message, server can include different fields in a single message
message ServerMsg
{
   // Session level messages from server.
   optional LogonResult logon_result = 100;
   optional RestoreOrJoinSessionResult restore_or_join_session_result = 101;
   repeated ConcurrentConnectionJoin concurrent_connection_join = 111;
   optional LoggedOff logged_off = 102;
   optional PasswordChangeResult password_change_result = 103;
   repeated UserMessage user_message = 104;
   repeated ObtainDemoCredentialsResult obtain_demo_credentials_result = 105;
   repeated UserSessionStateResult user_session_state_result = 106;
   optional Ping ping = 107;
   optional Pong pong = 108;
   optional LogonRoutineServer logon_routine_server = 109;
   optional PasswordChangeRoutineServer password_change_routine_server = 110;

   // Reports with requested information.
   repeated InformationReport information_report = 1;

   // Trade routing messages from server.
   repeated OrderRequestReject order_request_reject = 2;
   repeated TradeSubscriptionStatus trade_subscription_status = 3;
   repeated TradeSnapshotCompletion trade_snapshot_completion = 4;
   repeated OrderStatus order_status = 5;
   repeated PositionStatus position_status = 6;
   repeated CollateralStatus collateral_status = 7;

   // Market data messages from server.
   repeated MarketDataSubscriptionStatus market_data_subscription_status = 8;
   repeated RealTimeMarketData real_time_market_data = 9;

   /// Results of user attributes operations.
   repeated ReadUserAttributeResult read_user_attribute_result = 10;
   repeated ModifyUserAttributeResult modify_user_attribute_result = 11;

   /// Historical data.
   repeated TimeAndSalesReport time_and_sales_report = 12;
   repeated TimeBarReport time_bar_report = 13;
   repeated VolumeProfileReport volume_profile_report = 14;
   repeated NonTimedBarReport non_timed_bar_report = 19;

   // Results of rules requests.
   repeated rules_1.RuleResult rule_result = 15;

   // Result messages for accounts that require separate authorization process.
   repeated AccountLogonResult account_logon_result = 16;
   repeated AccountPasswordChangeResult account_password_change_result = 17;
   repeated AccountLogoffResult account_logoff_result = 18;

   // Result of Meta-data change request.
   repeated metadata_1.MetadataAdminResult metadata_admin_result = 20;
}

////------------------------------------------
//// Session level messaging

// Placeholder message of real-time Collapsing level enumeration (some libraries do not support enumerations outside of messages)
// Collapsing is a mechanism of eliminating some intermediate quotes to present more up-to-date market data
// instead of falling behind.
// It is started dynamically by server if client is not able to consume all requested feed timely
// e.g. because of a narrow network channel or client side hardware/ software issues.
message RealTimeCollapsing
{
   enum Level
   {
      // Collapsing is not not preferred.
      NONE = 0;

      // DOM data is collapsed.
      DOM = 1;

      // DOM and best bid/ ask quotes are collapsed delivering only last BBA but all trades.
      DOM_BBA = 2;

      // DOM, best bid/ ask and trades quotes are collapsed delivering only last values.
      DOM_BBA_TRADES = 3;
   }
}

// Logon into the system and opening a new session.
// Clients should either use user_name/password or access_token to enter the system.
message Logon
{
   // User login name.
   // It is not used along with access_token.
   optional string user_name = 1;

   // User's password.
   // It is not used along with access_token.
   optional string password = 2;

   // Access token.
   // It is not used along with user_name, password and one_time_password.
   optional string access_token = 14;

   // User's one time password, might be required according to the user's settings.
   optional string one_time_password = 3;

   // Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
   optional string private_label = 4;

   // Identifier of the client application as assigned by CQG.
   required string client_app_id = 5;

   // Version of a client application.
   required string client_version = 6;

   // Optional field that indicates if possible concurrent sessions for this user should be forcedly dropped.
   // If it is set to false then Logon may fail with CONCURRENT_SESSION code.
   // If it is omitted or set to true then concurrent sessions for this user will be dropped.
   optional bool drop_concurrent_session = 7;

   // Maximum allowed real-time market data collapsing level.
   // DOM_BBA_TRADES is the default allowed collapsing level.
   // This field is associated with RealTimeCollapsing.Level enum type.
   // Only one of collapsing_level and bandwidth can be specified.
   optional uint32 collapsing_level = 8;

   // Current protocol version that is used by the client application.
   // It is strongly recommended for client applications to put PROTOCOL_VERSION_MAJOR and PROTOCOL_VERSION_MINOR values from a used protocol file.
   // If version information is not provided then Server assumes client uses 0.x version of the protocol and may disable some new protocol features.
   optional uint32 protocol_version_minor = 9;
   optional uint32 protocol_version_major = 10;

   enum SessionSetting
   {
      // Allows restoring session in case of an accidental disconnect (see RestoreOrJoinSession message).
      // If the setting is not specified then termination of the last connection also terminates the session without ability to restore it.
      // For security reasons clients should not specify this setting without using the restore session functionality.
      ALLOW_SESSION_RESTORE = 1;

      // Allows other new connections to join the session (see RestoreOrJoinSession message) and work concurrently.
      // If the setting is not specified then the session can have only one connection at each moment and a new connection pushes the old one out (if the session restore is allowed).
      // For security reasons clients should not specify this setting without using join session functionality.
      ALLOW_SESSION_JOIN = 2;
   }

   // List of settings for a new session.
   // This field is associated with SessionSetting enum type.
   repeated uint32 session_settings = 11;

   // Real-time market data bandwidth limit (in KB per second).
   // Only one of collapsing_level and bandwidth can be specified.
   optional uint32 bandwidth = 12;

   // Dialect ID for used symbols.
   // CQG dialect is used if omitted.
   // Id for CQG dialect is 0.
   // Please contact CQG to get the list of supported dialects.
   optional string dialect_id = 13;

   // Fingerprint of a client application installation on a particular device.
   // This is just a string from the server perspective. Clients should make
   // sure it stays the same across runs of the application installation on
   // a specific device or Web application in a specific browser on this
   // device. Possible approaches to get the value on the client side:
   // http://clientjs.org/
   // https://developer.android.com/training/articles/user-data-ids.html
   optional string fingerprint = 15;

   // Client's operating system (with version, e.g. "Windows 7" or "Android").
   optional string operating_system = 16;

   // Client's browser name (if applicable, without version, e.g. "Chrome" or "Firefox")
   optional string browser = 17;

   // Client's device model (specific names for mobile, like "iPhone 7", or "PC" if not mobile/tablet).
   optional string device_model = 18;
}

// Result of the logon operation (for Logon and LogonRoutineClient messages).
message LogonResult
{
   enum ResultCode
   {
      //// success codes
      // User is logged in to the system.
      SUCCESS = 0;

      //// failure codes (100+)
      // General failure.
      FAILURE = 101;

      // One-time password is required for this user but it was not sent, repeat logon
      // with one-time password.
      NO_ONETIME_PASSWORD = 103;

      // User password is expired, only change password operation is allowed.
      PASSWORD_EXPIRED = 104;

      // Failed because this user has a concurrent session that is
      // not allowed for this application and drop was not requested.
      CONCURRENT_SESSION = 105;

      // Client is redirected to a different server, new server is specified in redirectUrl.
      REDIRECTED = 106;

      // The negotiation rules for LogonRoutineClient have been violated, e.g. user has specified several fields at once in one message.
      ROUTINE_ERROR = 107;

      // Access token is expired already.
      ACCESS_TOKEN_EXPIRED = 108;
   }

   // One of the logon result codes.
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 1;

   // Base time as ISO 8601 string (e.g. '2013-04-03T14:23:20')
   // all other times are number of milliseconds from this base time.
   required string base_time = 2;

   // Token of a new session if logon succeeded.
   optional string session_token = 3;

   // Optional logon result message for failure details.
   optional string text_message = 4;

   // URL for a client to reconnect in case of redirection.
   optional string redirect_url = 5;

   // Current protocol version of server. Normally client application need nothing to do with it.
   required uint32 protocol_version_minor = 6;
   required uint32 protocol_version_major = 7;

   // Unique user identification
   optional sint32 user_id = 8;

   // Time when the message was sent.
   required sint64 server_time = 9;

   // Timeout of session inactivity, number of minutes. This is clients'
   // responsibility to track activity and disable/close the session after
   // the timeout.
   optional uint32 inactivity_timeout = 10;
}

// Message for multi-step logon which user should use in case if it is required to use encoded password.
// Multi-step logon sequence has the following steps:
//      1) Client initiates logon negotiation by sending LogonRoutineClient.logon_init message to the server.
//      2) Server sends one or more LogonRoutineServer.password_request messages (this step may repeat after step #3).
//      3) Client sends list of LogonRoutineClient.password_response back to the server.
//      4) Server optionally asks accept trader's agreement (LogonRoutineServer.trader_agreement_url).
//      5) Client responds with LogonRoutineClient.trader_agreement_accepted equal to True
//         if the user accepts agreement, False or LogonRoutineClient.abort_logon otherwise.
//      6) Server sends LogonRoutineServer.logon_result as the final message of the negotiation with the results.
//   Client may stop the negotiation by sending LogonRoutineClient.abort_logon message in response to any server
//      LogonRoutineServer.password_request or LogonRoutineServer.trader_agreement_url requests.
// NOTE: only one of fields has to be specified.
message LogonRoutineClient
{
   // Initiating of multi-step logon process by client.
   optional LogonInit logon_init = 1;

   // List of passwords in response to request from server.
   // The number of passwords in response should be equal to the number of passwords in request from server.
   repeated PasswordResponse password_response = 2;

   // True means user has accepted the trader agreement.
   optional bool trader_agreement_accepted = 3;

   // Aborting of multi-step logon process by client.
   optional AbortRoutine abort_logon = 4;
}

// Response to the LogonRoutineClient message. Only one of fields is specified.
message LogonRoutineServer
{
   // Final message of the negotiation with the results.
   optional LogonResult logon_result = 1;

   // List of requested passwords.
   repeated PasswordRequest password_request = 2;

   // URL pointing to the location of help information for this version of agreement.
   // Specified if user should accept trader's agreement in order to continue logon process.
   optional string trader_agreement_url = 3;
}

// Message for multi-step password change which user should use in case if it is required to use encoded password.
// Multi-step password change sequence has the following steps:
//      1) Client initiates password change procedure by sending PasswordChangeRoutineClient.init_password_change to the server.
//      2) Server sends one or more PasswordChangeRoutineServer.password_request messages (this step may repeat after step #3).
//      3) Client sends list of PasswordChangeRoutineClient.password_response back to the server.
//      4) Server sends PasswordChangeRoutineServer.password_change_result as the final message of the negotiation with the results.
//   Client may stop the negotiation by sending PasswordChangeRoutineClient.abort_password_change message in response to any server
//      PasswordChangeRoutineServer.password_request message.
// NOTE: only one of fields has to be specified.
message PasswordChangeRoutineClient
{
   // True means user has decided to initiate password changing procedure.
   optional bool init_password_change = 1;

   // List of passwords in response to request from server.
   // The number of passwords in response should be equal to the number of passwords in request from server.
   repeated PasswordResponse password_response = 2;

   // Aborting of multi-step password change process by client.
   optional AbortRoutine abort_password_change = 3;
}

// Response to the PasswordChangeRoutineClient message. Only one of fields is specified.
message PasswordChangeRoutineServer
{
   // List of requested passwords.
   repeated PasswordRequest password_request = 1;

   // Final message of the negotiation with the results.
   optional PasswordChangeResult password_change_result = 2;
}

// This message indicates that user has decided to abort the logon or password change processes.
message AbortRoutine
{
   // Reason of logon or password change routine abort.
   optional string comment = 1;
}

// Initiating of multi-step logon process by client. See description of fields in Logon message.
message LogonInit
{
   required string user_name = 1;
   optional string private_label = 2;
   required string client_app_id = 3;
   required string client_version = 4;
   optional bool drop_concurrent_session = 5;
   optional uint32 collapsing_level = 6;

   optional uint32 protocol_version_minor = 7;
   optional uint32 protocol_version_major = 8;
   repeated uint32 session_settings = 9;
   optional uint32 bandwidth = 10;
   optional string dialect_id = 11;
   optional string fingerprint = 12;
   optional string operating_system = 13;
   optional string browser = 14;
   optional string device_model = 15;
}

// Parameters of requesting password from user.
message PasswordRequest
{
   enum PasswordType
   {
      // Currently used password.
      STATIC = 1;

      // One-time password.
      ONE_TIME = 2;

      // New password that user wants to use. Can be specified only in result of PasswordChangeRoutineClient.
      NEW_STATIC = 3;

      // Currently used password and new password that user wants to use. Can be specified only in result of PasswordChangeRoutineClient.
      CUR_AND_NEW_STATIC = 4;

      // Non-password request with question e.g. "What is your favorite pet?".
      TEXT = 5;
   }

   // ID of a request.
   required uint32 request_id = 1;

   // Type of password which server requests from the user.
   // This field is associated with PasswordType enum type.
   required uint32 password_type = 2;

   // Commonly understood code that can be used to show an additional localized prompt for certain password types.
   optional string user_prompt_type = 3;

   // Alternate English text for clients which do not recognize user_prompt_type. This text can be displayed as-is to the user.
   // NOTE: user_prompt_type and user_prompt_type_alt are a pair (so either none or both are provided).
   optional string user_prompt_type_alt = 4;

   // Text that should be displayed to the user as-is along with the localized prompt implied by user_prompt_type.
   // If user_prompt_type_alt is used instead, this text should be displayed after it.
   // user_prompt will only be provided if user_prompt_type and user_prompt_type_alt are provided, but it is optional even then.
   optional string user_prompt = 5;

   // Set of supported encodings for this request. Client should choose the encoding with highest priority from among those it implements.
   repeated Encoding encoding = 6;
}

// Response to the PasswordRequest message.
message PasswordResponse
{
   // ID of corresponding password request.
   required uint32 request_id = 1;

   // Commonly understood string that identifies the password encoding method.
   required string encoding_type = 2;

   // User's password encoded with specified encoding method.
   required string password = 3;
}

// Description of the encoding method.
message Encoding
{
   // Commonly understood string that identifies the encoding method.
   // The following encodings are available: "none", "ds3_rsa", "isprint_e2ee".
   required string encoding_type = 1;

   // The priority for this encoding, value 1 is highest priority, 2 is next priority, etc.
   required uint32 priority_rank = 2;

   // Encoding parameters for this encoding method.
   repeated EncodingParameter encoding_parameter = 3;
}

// The encoding parameter.
message EncodingParameter
{
   // Encoding parameter's name.
   required string name = 1;

   // Encoding parameter's value.
   required string value = 2;
}

// Client request to restore session because of accidental disconnect or to join additional concurrent connection to existing session.
// This message allows to avoid prompting user for [one-time] password.
// In case of session restore client application has to [re-]subscribe and [re-]request necessary data.
// Permissions to use this functionality is regulated by ALLOW_SESSION_RESTORE/ALLOW_SESSION_JOIN session settings which are specified in Logon or LogonInit message.
message RestoreOrJoinSession
{
   // Token of the session to restore/join, it has limited lifetime after disconnect of the last connection.
   required string session_token = 1;

   // Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
   optional string private_label = 2;

   // Identifier of the client application as assigned by CQG.
   // This field is required to be specified and left optional only for backward compatibility.
   optional string client_app_id = 3;

   // Maximum allowed real-time market data collapsing level.
   // DOM_BBA_TRADES is the default allowed collapsing level.
   // This field is associated with RealTimeCollapsing.Level enum type.
   // Only one of collapsing_level and bandwidth can be specified.
   optional uint32 collapsing_level = 4;

   // Current protocol version that is used by the client application.
   // It is strongly recommended for client applications to put PROTOCOL_VERSION_MAJOR and PROTOCOL_VERSION_MINOR values from a used protocol file.
   // If version information is not provided then Server assumes client uses 0.x version of the protocol and may disable some new protocol features.
   optional uint32 protocol_version_minor = 5;
   optional uint32 protocol_version_major = 6;

   // Real-time market data bandwidth limit (in KB per second).
   // Only one of collapsing_level and bandwidth can be specified.
   optional uint32 bandwidth = 7;
}

// Result of session restore or join attempt.
message RestoreOrJoinSessionResult
{
   enum ResultCode
   {
      //// success codes
      // User is logged in to the system.
      SUCCESS = 0;

      //// failure codes (100+)
      // General failure.
      FAILURE = 104;

      // Session is unknown to a server, client must perform standard logon procedure.
      UNKNOWN_SESSION = 101;

      // User is not allowed to perform session restore/join or the maximum connection number has been exceeded.
      ACCESS_DENIED = 102;

      // Some RestoreOrJoinSession message fields were not filled.
      INVALID_PARAMS = 103;
   }

   // Session restore/join result.
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 1;

   // Session base time (see LogonResult.base_time).
   required string base_time = 2;

   // Optional failure details.
   optional string text_message = 3;

   // Time when the message was sent.
   required sint64 server_time = 4;

   // Session default dialect ID for used symbols (see Logon.dialect_id).
   optional string dialect_id = 5;

   // Timeout of session inactivity, number of minutes. This is clients'
   // responsibility to track activity and disable/close the session after
   // the timeout (see LogonResult.inactivity_timeout).
   optional uint32 inactivity_timeout = 6;
}

// Notifies about joining of a concurrent connection to the session (see RestoreOrJoinSession).
message ConcurrentConnectionJoin
{
   // Shows if new connection has been initiated by an application of the same type (with the same private_label and client_app_id fields).
   required bool is_same_app_type = 1;
}

// Client request to logoff from the system and close the session.
message Logoff
{
   // Optional logoff reason.
   optional string text_message = 1;
}

// Server notification about closing user's session,
// server closes connection after this message.
message LoggedOff
{
   enum LogoffReason
   {
      // User is logged off by client request.
      BY_REQUEST = 1;

      // User is redirected to another URL.
      REDIRECTED = 2;

      // System logged off the user because of some server side reason.
      FORCED = 3;

      // System logged off the user because this session was re-assigned to another connection
      // that took it over by 'restore session' operation
      REASSIGNED = 4;
   }

   // One of the logoff reasons.
   // This field is associated with LogoffReason enum type.
   required uint32 logoff_reason = 1;

   // Optional logoff details.
   optional string text_message = 2;

   // URL for redirection.
   optional string redirect_url = 3;
}

// Message to change user's password.
message PasswordChange
{
   // Currently used password.
   required string old_password = 1;

   // New password that user wants to use.
   required string new_password = 2;
}

// Result of user password change (for PasswordChange and PasswordChangeRoutineClient messages).
message PasswordChangeResult
{
   // Password change result.
   enum ResultCode
   {
      /// success codes
      // User password is changed successfully.
      SUCCESS = 0;

      /// failure codes (100+)
      // Incorrect user name or password.
      FAILURE = 101;

      // The negotiation rules for PasswordChangeRoutineClient have been violated, e.g. user has specified several fields at once in one message.
      ROUTINE_ERROR = 102;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 1;

   // Optional failure details.
   optional string text_message = 2;
}

// request for temporary user name and password for demo
// Clients of ObtainDemoCredentials are responsible to verify provided e-mail (e.g. by sending passwords by e-mail only) and prevent possible abuse.
// ObtainDemoCredentials requests are accepted only if client IP address is in the list of allowed IP addresses for service requests
message ObtainDemoCredentials
{
   // Identifier of the client application as assigned by CQG.
   required string client_app_id = 1;

   // User first name
   required string first_name = 2;

   // User second name
   required string second_name = 3;

   // E-mail address of a user who requested demo access.
   required string e_mail = 4;

   // Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
   optional string private_label = 5;
}

message ObtainDemoCredentialsResult
{
   // Password change result.
   enum ResultCode
   {
      /// success codes (0 - 100)
      SUCCESS = 0;

      /// failure codes (100+)
      FAILURE = 101;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 1;

   // demo user name
   optional string user_name = 2;

   // demo password
   optional string password = 3;

   // Optional details.
   optional string text_message = 4;

   // Unique user identification.
   // Required in case of success.
   optional sint32 user_id = 5;

   // Expiration date/time in UTC as ISO 8601 string (e.g. '2013-04-03T14:23:20Z').
   optional string expiration_utc = 6;
}

// Text message from server.
message UserMessage
{
   // Type of the message.
   enum MessageType
   {
      // Critical error message.
      CRITICAL_ERROR = 1;

      // Warning.
      WARNING = 2;

      // General information.
      INFO = 3;

      // This message shouldn't be visible for users, only dumped into a log file.
      LOG = 4;
   }
   // This field is associated with MessageType enum type.
   required uint32 message_type = 1;

   // Information about source of the message.
   required string source = 2;

   // Message subject.
   optional string subject = 3;

   // Message text.
   required string text = 4;

   // Optional time when this message is expired, it should be hidden from user after this time (UTC).
   optional sint64 expiration_utc_time = 5;
}

// Request information about user session.
// UserSessionState requests are accepted only if client ip address is in the list of allowed IP addresses for service requests
message UserSessionStateRequest
{
   required string session_token = 1;
}

message UserSessionStateResult
{
   // Session token from UserSessionStateRequest.
   required string session_token = 1;

   enum ResultCode
   {
      //// success codes
      // Data for requested session is found.
      SUCCESS = 0;

      //// failure codes (100+)
      // General failure.
      FAILURE = 101;

      // Session is unknown to a server.
      UNKNOWN_SESSION = 102;

      // The user is not allowed to access this data.
      ACCESS_DENIED = 103;
   }

   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   /// User session information.
   optional sint32 user_id = 3;
   optional string username = 4;
}

// Ping request which can be initiated by any side to ensure connection is alive. Both client and
// server sides must respond such request with Pong.
message Ping
{
   // Token routed back in Pong response.
   optional string token = 1;

   // UTC time when this request was composed. Used for network latency diagnostics.
   required sint64 ping_utc_time = 2;
}

// Pong response which must be sent in response on Ping request.
message Pong
{
   // Token passed in Ping request.
   optional string token = 1;

   // Corresponding value from Ping request.
   required sint64 ping_utc_time = 2;

   // UTC time when this response was composed.
   required sint64 pong_utc_time = 3;
}


////------------------------------------------
//// Market and Trade Routing Common messages

// Message to define a synthetic or a user defined strategy, a tree where terminal nodes (legs) are concrete contracts,
// non-terminal ones are nested strategies.
// Nodes are defined from the BUY perspective.
// Maximum strategy nesting level is 2, i.e. strategy of strategies of legs.
// Maximum number of leg in the whole strategy is 40.
message StrategyDefinition
{
   // Using a fractional trade ratio may result in fractional lots. If so, the number of lots has to be rounded.
   // Rounding applies only to complex strategies with fractional quantity ratios.
   enum RoundLegMode
   {
      // always round down, e.g. 1.1 -> 1 and -2.1 -> -2
      DOWN = 1;

      // always round up, e.g. 1.1 -> 2 and -2.1 -> -3
      UP = 2;

      // round up when fractional part is 5 or greater; round down when fractional part is less than 5, e.g. 1.1 -> 1 and 1.6 -> 2
      MATH = 3;
   }

   // The strategy is of the aggregation type.
   optional bool aggregation = 1;

   // If specified defines exchange strategy.
   optional ExchangeStrategy exchange_strategy = 2;

   // Strategy tick size (correct price format). The tick size of the 1st leg is default.
   optional double tick_size = 3;

   // Additive offset for computation of strategy price.
   // 0 is default.
   optional double price_offset = 4;

   // Controls how to handle fractional quantities when calculating leg quantities for an order on this strategy,
   // One of RoundLegMode enums, DOWN is default. Ignored for aggregations and exchange strategies.
   optional uint32 round_leg_mode = 5;

   // Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
   required uint32 node_index = 6;

   // Legs or nested strategies.
   repeated StrategyNodeDefinition node_definition = 7;

   // User text associated with the strategy. Allowed to be specified only for non-exchange strategies.
   optional string user_description = 8;
}

// Defines a strategy created by an individual and registered by an exchange for general open market trading.
// Must be a root strategy without nested nodes and cannot be an aggregation.
message ExchangeStrategy
{
   // Value of this field might be chosen from the predefined list to specify exchange strategy type.
   // Please contact CQG to get the list of supported types.
   // "custom" if omitted.
   optional string exchange_strategy_type = 1;
}

// Defines a leg (resolved contract) of a strategy.
message LegDefinition
{
   // Id of the leg contract.
   required uint32 contract_id = 1;

   // Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
   required uint32 node_index = 2;

   // Leg quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative). Must be integer for an aggregation.
   required double qty_ratio = 3;

   // Leg price calculation ratio, signed decimal, coefficient in strategy price formula before the leg contract.
   // Same as qty_ratio if omitted.
   optional double price_ratio = 4;

   // Price offset for this leg (correct price format), only specified for legs of an aggregation or a multiplicative strategy.
   // 0 is default.
   optional double price_offset = 5;
}

// Defines a strategy nested inside a parent strategy.
message NestedStrategy
{
   // Nested strategy definition.
   required StrategyDefinition definition = 1;

   // Quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative).
   // Default is 1.
   optional double qty_ratio = 2;

   // Leg price calculation ratio, signed decimal, coefficient in strategy price formula.
   // Same as qty_ratio if omitted.
   optional double price_ratio = 3;
}

// Child node definition within the parent strategy tree. Can be either a resolved contract (leg) or a nested strategy.
message StrategyNodeDefinition
{
   // Operation on a node of the synthetic strategy.
   // Associating an operation with a node allows using different operations, e.g. multiplication and subtraction,
   // without introducing intermediate StrategyDefinition entities.
   // MUL and DIV cannot be mixed with SUM within the same StrategyDefinition.node_definition array.
   // i.e. node1 / node2 * node3 is allowed, but node1 / node2 + node3 is not.
   enum NodeOperation
   {
      // Add the quantity and the price.
      SUM = 1;

      // Add the quantity but multiply the price.
      MUL = 2;

      // Subtract the quantity but divide the price.
      DIV = 3;
   }

   // Specified node operation, one of NodeOperation enums, the default is SUM.
   optional uint32 node_operation = 2;

   // Leg definition, if the node is a resolved contract.
   optional LegDefinition leg = 3;

   // Nested strategy, mutually exclusive with 'leg' attribute.
   optional NestedStrategy nested_strategy = 4;
}

// Describes tick size and value, and the range of prices they apply in.
message TickSizeByPrice
{
   // Size or a single market tick in correct price format.
   required double tick_size = 1;

   // Contract tick money value in the contract's currency.
   // Zero if not applicable (e.g. for indexes).
   required double tick_value = 2;

   // The tick size and value apply from this price (inclusive) and upper, to the next TickSizeByPrice.minimum_price, if any.
   // The price is in correct price format.
   required double minimum_price = 3;
}

// Describes tick size and value applied within some range of dates.
message TickSizeByDateTillExpiration
{
   // Id of the record.  Starts from 0.  The record with id of 0 applies immediately before contract expiration, id of 1
   // applies before 0th, etc.
   required uint32 id = 1;

   // Size or a single market tick in correct price format.
   required double tick_size = 2;

   // Contract tick money value in the contract's currency.
   // Zero if not applicable (e.g. for indexes).
   required double tick_value = 3;
}

// Way how to track the trader's open positions on a given contract.
enum PositionTrackingType
{
   // Difference between long and short open positions is tracked.
   NET_POSITION = 1;

   // Long and short open positions are tracked separately.
   LONG_SHORT_WITH_IMPLIED_CLOSE = 2;

   // Long and short as well as today and yesterday open positions are tracked separately.
   // The explicit order instruction to close either today or yesterday is taken into account.
   LONG_SHORT_WITH_EXPLICIT_CLOSE = 3;
}


// Recommended display mode for prices.
// The rules are applied according to the display scale of a contract.
// For combined scales like Eighths of Thirty Seconds the mode is applied only to the minor fractions (Eighths) while
// the major fractions (Thirty Seconds) always shown in NUMERATOR mode.
// Sample: TRUNCATED mode for 108 22/32 with extra 7/8 of 1/32 (108 + 22/32 + 7/256) is shown as 108'228 where 8 is calculated
// as 7/8 -> truncate (0.875) -> 8 (see TRUNCATED sample below).
enum PriceDisplayMode
{
   // The numerator of the fractional part is shown directly.
   // Samples: for 3/8 the fractional part is shown as '3', for 7/16 - '07', for 15/100 - '15' etc.
   NUMERATOR = 0;

   // Rounded decimal. In this mode the fractional part is converted to the decimal fraction
   // and then rounded to the minimum digits which are necessary to recognize the price.
   // Samples: 3/8 -> round(0.375) -> '4', 7/8 Â¨C round(0.875) -> '9', 11/16 -> round(0.6875) -> '69'.
   // It means the same as NUMERATOR for decimal scales.
   ROUNDED  = 1;

   // Truncated decimal. In this mode the fractional part is converted to the decimal fraction
   // and then truncated to the minimum digits which are necessary to recognize the price.
   // Samples: 3/8 -> truncate(0.375) -> '3', 7/8 -> truncate (0.875) -> '8', 11/16 -> truncate (0.6875) -> '68'.
   // It means the same as NUMERATOR for decimal scales.
   TRUNCATED = 2;
}

// Describes period value type.
// See example in ContractMetadata.period_type and ContractMetadata.period_value
enum PeriodType
{
   MONTH = 0;
   QUARTER = 1;
   SEMI_ANNUAL = 2;
   YEAR = 3;
   DAY_OF_WEEK = 4;
   DAY_OF_MONTH = 5;
   DAY_OF_YEAR = 6;
   WEEK_OF_MONTH = 7;
   WEEK_OF_YEAR = 8;
   SECOND = 9;
   MINUTE = 10;
   HOUR = 11;
   DATE = 12;
}

message ContractMetadata
{
   // Server assigned ID for a contract, it is not the same across sessions.
   required uint32 contract_id = 1;

   // Full contract symbol.
   required string contract_symbol = 2;

   // Scale to convert prices from this protocol to correct prices
   // (correctPrice = price * correctPriceScale).
   required double correct_price_scale = 3;

   // Display Price Scale is a number that defines conversion of float correct price to
   // a 'native' integer display format and back
   // Below is the table of possible scale values
   // -------------------------------------------------------
   // | Scale |       Name            |    Description      |
   // -------------------------------------------------------
   // | 0     |One                     |Don't scale         |
   // | 1     |TenMinusOne             |Divide by 10        |
   // | 2     |TenMinusTwo             |Divide by 100       |
   // | 3     |TenMinusThree           |Divide by 1000      |
   // | 4     |TenMinusFour            |Divide by 10000     |
   // | 5     |TenMinusFive            |Divide by 100000    |
   // | 6     |TenMinusSix             |Divide by 1000000   |
   // | 7     |TenMinusSeven           |Divide by 10000000  |
   // | 8     |TenMinusEight           |Divide by 100000000 |
   // | 9     |TenMinusNine            |Divide by 1000000000|
   // | 10    |TenMinusTen             |Divide by 10^10     |
   // | 11    |TenMinusEleven          |Divide by 10^11     |
   // | 12    |TenMinusTwelve          |Divide by 10^12     |
   // | 13    |TenMinusThirteen        |Divide by 10^13     |
   // | 14    |TenMinusFourteen        |Divide by 10^14     |
   // | 15    |TenMinusFifteen         |Divide by 10^15     |
   // | 101   |Halves                  |Divide by 2         |
   // | 102   |Fourths                 |Divide by 4         |
   // | 103   |Eighths                 |Divide by 8         |
   // | 104   |Sixteenths              |Divide by 16        |
   // | 105   |ThirtySeconds           |Divide by 32        |
   // | 106   |SixtyFourths            |Divide by 64        |
   // | 107   |OneHundredTwentyEighths |Divide by 128       |
   // | 108   |TwoHundredFiftySixths   |Divide by 256       |
   // | 109   |FiveHundredTwelths      |Divide by 512       |
   // | 110   |OneThousandTwentyFourths|Divide by 1024      |
   // | 201   |HalfThirtySeconds       |Similar to 64ths    |
   // | 202   |QuarterThirtySeconds    |Similar to 128ths   |
   // | 203   |EighthThirtySeconds     |Similar to 256ths   |
   // | 204   |HalfSixtyFourths        |Similar to 128ths   |
   // | 205   |QuarterSixtyFourths     |Similar to 256ths   |
   // | 206   |SixteenthThirtySeconds  |Similar to 512ths   |
   // -------------------------------------------------------
   required uint32 display_price_scale = 4;

   // Discretionary Display Price Scale if applicable.
   // See display_price_scale above for possible values.
   optional uint32 discretionary_display_price_scale = 37;

   // Contract description.
   required string description = 5;

   // Contract description with additional information, e.g. strategy legs.
   optional string extended_description = 43;

   // Contract display name.
   required string title = 6;

   // Size or a single market tick in correct price format.
   required double tick_size = 7;

   // Size or a single discretionary tick in correct price format if applicable.
   // Note: to get number of discretionary ticks between nearest regular prices use:
   // ((tick_size / discretionary_tick_size) - 1)
   optional double discretionary_tick_size = 36;

   // Contract currency code (ISO 4217 based).
   // Empty string if not applicable (e.g. for indexes).
   required string currency = 8;

   // Contract tick money value in the contract's currency.
   // Zero if not applicable (e.g. for indexes).
   required double tick_value = 9;

   // CFI code (Classification of Financial Instruments, ISO 10962).
   required string cfi_code = 10;

   // True if this contract is the most active one for derivatives.
   optional bool is_most_active = 11;

   // Contract trading date for derivatives
   // (local exchange date in time format, use date part only).
   optional sint64 last_trading_date = 12;

   // Contract first notice date
   // (local exchange date in time format, use date part only).
   optional sint64 first_notice_date = 13;

   // Underlying contract symbol (e.g. for options).
   optional string underlying_contract_symbol = 14;

   // Margin style (for options).
   enum MarginStyle
   {
      // The premium is paid on exercise/ expiry (position is included to OTE calculation).
      FUTURE = 1;

      // Premium is subtracted from account balance when order is filled (position is included to MVO/UPL calculation).
      PREMIUM = 2;
   }
   // This field is associated with MarginStyle enum type.
   optional uint32 margin_style = 15;

   // Name of a group of contracts that share the same properties (e.g. commodity name for futures and options)
   required string instrument_group_name = 16;

   // ID of a session information this contract is related to.
   required sint32 session_info_id = 17;

   // Market segment MIC (ISO 10383) of the contract (if available), e.g. 'GLBX'.
   optional string mic = 18;

   // Market segment MIC description (ISO 10383) of the contract (if available), e.g. 'CME GLOBEX'
   optional string mic_description = 44;

   // If user is allowed to receive only delayed data of the contract
   // then this parameter is set to the delay value in milliseconds.
   optional sint64 market_data_delay = 20;

   // If user is not allowed to receive quotes then End of Day (EOD) data for this contract can be allowed.
   // In case of real-time market data subscriptions only level MARKET_VALUES is supported.
   // In case of time bar requests only Daily (or larger) bars are supported.
   // Note: Data for current and previous trading days are available only if corresponding trading day
   // was closed |end_of_day_delay| milliseconds ago.
   optional sint64 end_of_day_delay = 59;

   // instrument group name without the prefix
   required string short_instrument_group_name = 21;

   // description of the instrument group
   required string instrument_group_description = 22;

   // Variable tick size by contract price (if available for the contract)
   // If variable tick sizes by contract price are available, tick_size and tick_value specify the minimal tick size
   // and value among these.
   // Only one of tick_sizes_by_price and tick_sizes_by_dte can be specified.
   repeated TickSizeByPrice tick_sizes_by_price = 23;

   // Variable tick size by date till expiration (if available for the contract).  Sorted by id in ascending order.
   // If variable tick sizes by DTE are available, tick_size and tick_value specify the tick size and value applicable at
   // the moment of symbol resolution.
   // Only one of tick_sizes_by_price and tick_sizes_by_dte can be specified.
   repeated TickSizeByDateTillExpiration tick_sizes_by_dte = 24;

   // Specifies which rule of TickSizeByDateTillExpiration applies now.
   optional uint32 tick_sizes_by_dte_id = 25;

   // Option strike display value.
   optional sint32 strike = 26;

   // Option strike price value (directly in correct format).
   optional double strike_price = 27;

   // Dialect of the contract symbol.
   // 0 - CQG dialect.
   optional string dialect_id = 28;

   // Two-letter exchange country code (ISO 3166-1 alpha 2).
   required string country_code = 29;

   // Strategy definition if the contract is of a synthetic or a user defined strategy.
   optional StrategyDefinition strategy_definition = 30;

   // The deliverable quantity of commodities or financial instruments underlying contract.
   // E.g. "1,000 U.S. Barrels (42,000) Gallons", "125,000 Euro"
   optional string contract_size = 31;

   // Setting which regulates how to calculate contract open positions.
   // PositionTrackingType.NET_POSITION, if not set.
   optional uint32 position_tracking = 32;

   // Setting which requires whether every contract order has to specify SpeculationType instruction or not.
   optional bool speculation_type_required = 33 [default = false];

   // Month letter and 2-digit year identifying the maturity month of the contract (if applicable).
   // Doesn't depend on dialect.
   // Month and corresponding letter:
   // January   F
   // February  G
   // March     H
   // April     J
   // May       K
   // June      M
   // July      N
   // August    Q
   // September U
   // October   V
   // November  X
   // December  Z
   optional string maturity_month_year = 34;

   // Contract's maturity date (e.g. for daily futures, when maturity_month_year is not enough).
   // (local exchange date in time format, use date part only).
   optional sint64 maturity_date = 53;

   // Recommended display mode for prices. See the PriceDisplayMode description.
   optional PriceDisplayMode price_display_mode = 35;

   // Discretionary Display Mode if applicable.
   // See PriceDisplayMode description.
   optional PriceDisplayMode discretionary_price_display_mode = 38;

   // Currency code (ISO 4217 based). For forex contracts only. Specifies the currency bought or sold.
   optional string foreign_currency = 39;

   // Specifies a volume unit of a contract, similar to correct_price_scale.
   // If a message contains a volume as uint64 (like Quote or TimeBar), its correct volume is calculated as:
   //   correct_volume = Quote.volume * volume_scale.
   // If a message contains a volume as cqg.Decimal, it is the correct volume.
   optional cqg.Decimal volume_scale = 40;

   // Specifies the recommended representation of volumes to users:
   //  - negative numbers - -N - mean that N decimal digits should be shown.
   //  - positive numbers - N - mean that N digits can be hidden behind a unit prefix (or unit symbol),
   //    e.g. if N = 3, volumes can be shown as "12k".
   optional sint32 volume_display_exponent = 41 [default = 0];

   // Trade volume is required to be a multiple of trade_size_increment.
   optional cqg.Decimal trade_size_increment = 42;

   // True if DOM views should be inverted: low numbers are at the top, high numbers are at the bottom.
   // This field is usually set for fixed income contracts with "prices are yields" model.
   optional bool has_inverted_price_ladder = 60;

   // The denominator (numerator is 1) of the DOM ladder compression ratio
   // to compress the ladder to eliminate all the extra/non-quoting values.
   optional uint32 dom_ladder_compression_ratio = 45;

   // Whether to expect that prices may appear not on the nominal tick prices
   // (not products of any tick_size: ordinal, variable, discretionary, etc.) to changes DOM UI behavior.
   // Format such prices according to display_price_scale rule.
   optional bool expect_off_tick_prices = 46 [default = false];

   // Specifies whether exchange provides volume data or not.
   optional bool has_exchange_volume = 47 [default = true];

   // True if the contract supports yields and you can request them with MarketDataSubscription.include_yields.
   // Note: In case the contract has "prices are yields" model this field is false and yields are provided
   // through the price field.
   optional bool has_yields = 61;

   // The ISIN code acts an identifier for the securities
   // And as such is the only common denominator securities identification number that is universally recognized.
   optional string isin = 48;

   // Reference value for maintenance margin (required to maintain 1 lot position
   // in this contract), expressed as money value in the contract's currency.
   // Note the value is informational only, not updated real-time, and does not
   // consider the account's portfolio or risk settings/parameters
   optional double maintenance_margin = 49;

   // Contract size in the number of units (where defined). Unit is defined by contract_size_unit filed.
   optional cqg.Decimal contract_size_in_units = 50;

   // Unit label for the contract size.
   optional shared_1.Text contract_size_unit = 51;

   // Contract last delivery date
   // (local exchange date in time format, use date part only).
   optional sint64 last_delivery_date = 52;

   // Optional custom contract parameters per associated contributor (if any).
   repeated metadata_1.ContributorParameters contributor_parameters = 54;

   // Period type. This field is associated with PeriodType enum type.
   optional uint32 period_type = 55;

   // Period value in period_type units.
   optional uint32 period_value = 56;

   // ID of the symbol the contract represents (Symbol.id attribute)
   optional string symbol_id = 57;

   // If contract metadata is "deleted", corresponding contract id can't be referred to in requests anymore
   // (this happens e.g. when published contract gets unpublished).
   optional bool deleted = 58 [default = false];
}

////------------------------------------------
//// Information Requests and Reports

// Request for information.
// There must be only one request type (e.g. accountsRequest and lastStatementBalancesRequest can not be sent at the same time).
message InformationRequest
{
   // ID of a request and optional subscription that should be unique enough to match responses and updates with corresponding requests.
   required uint32 id = 1;

   // If set to true then corresponding reports are also sent when requested information is changed during the session,
   // if set to false then subscription is dropped,
   // if omitted then data is returned without changing subscription status.
   optional bool subscribe = 2;

   // Request for authorized accounts for trading.
   // Only one subscription is possible.
   // Requests rate is limited, 100 per 24 hours by default.
   // Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
   optional AccountsRequest accounts_request = 3;

   // Request symbol resolution with optional subscription.
   // Requests rate is limited, 10000 per 24 hours by default.
   // NOTE: subscription is essential to follow active contract switching.
   optional SymbolResolutionRequest symbol_resolution_request = 4;

   // Request for balances from the last statement for all authorized accounts.
   // Only one subscription is possible.
   // Requests rate is limited, 100 per 24 hours by default.
   // Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
   optional LastStatementBalancesRequest last_statement_balances_request = 5;

   // Request for currency rates for all brokerages user's accounts belong to.
   // Only one subscription is possible.
   // Requests rate is limited, 100 per 24 hours by default.
   // Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
   optional CurrencyRatesRequest currency_rates_request = 6;

   // Request for session information.
   // Number of simultaneous requests in processing is limited, 10 by default.
   // Number of simultaneous session information update subscriptions is limited, 200 by default.
   // Requests are accepted only if the user is not subscribed for this information at the moment.
   optional SessionInformationRequest session_information_request = 7;

   // Request for a list of historical orders (including all transactions) according to a search criteria.
   // Number of simultaneous requests in processing is limited, 1 by default.
   // The request depth is limited, 30 days by default.
   // Subscription is not supported for this request.
   optional HistoricalOrdersRequest historical_orders_request = 13;

   // Request a list of child symbols for an underlying contract.
   // Number of simultaneous requests in processing is limited, 5 by default.
   // Number of simultaneous update subscriptions is limited, 100 by default.
   optional SymbolsByUnderlyingRequest symbols_by_underlying_request = 14;

   // Request a list of child symbols for a higher level symbol.
   // Number of simultaneous requests in processing is limited, 5 by default.
   // Number of simultaneous update subscriptions is limited, 100 by default.
   optional ChildSymbolsRequest child_symbols_request = 15;

   // Request at-the-money strike for the option maturity.
   // Number of simultaneous requests in processing is limited, 5 by default.
   // Number of simultaneous update subscriptions is limited, 100 by default.
   optional AtTheMoneyStrikeRequest at_the_money_strike_request = 16;

   // Request strategy definition with no subscription.
   // Requests rate is limited, 10000 per 24 hours by default.
   optional StrategyDefinitionRequest strategy_definition_request = 17;

   // Request for session timerange information.
   // Number of simultaneous requests in processing is limited, 10 by default.
   // The request range is limited. 1 year/1000 sessions by default.
   // Subscription is NOT supported for this request, so subscribe flag will be ignored.
   optional SessionTimeRangeRequest session_timerange_request = 18;

   // Request for trading day timerange information.
   // Number of simultaneous requests in processing is limited, 10 by default.
   // The request range is limited. 1 year/250 trading days by default.
   // Subscription is NOT supported for this request, so subscribe flag will be ignored.
   optional TradingDayTimeRangeRequest trading_day_timerange_request = 19;

   // Request of order entitlements.
   // Number of simultaneous requests in processing is limited, 100 by default.
   // Subscription is not supported for this request.
   optional OrderEntitlementRequest order_entitlement_request = 20;

   // Request for a symbol category tree for a particular root. each category can have a list of sub-categories.
   // Number of simultaneous requests in processing is limited, 100 by default.
   // Number of simultaneous update subscriptions is limited, 100 by default.
   // There can be only one subscription per category root for updates.
   optional SymbolCategoryListRequest symbol_category_list_request = 21;
   
   // Request for a specific category by its ID.
   // Number of simultaneous requests in processing is limited, 1000 by default.
   // Number of simultaneous update subscriptions is limited, 1000 by default.
   optional SymbolCategoryRequest symbol_category_request = 27;

   // Request for a list of symbols according to a specified filter.
   // Number of simultaneous requests in processing is limited, 150 by default.
   // Number of simultaneous update subscriptions is limited, 150 by default.
   optional SymbolListRequest symbol_list_request = 22;

   // Request for a specific symbol by its ID.
   // Requests rate is limited, 10000 per 24 hours by default.
   // Number of simultaneous requests in processing is limited, 150 by default.
   // Subscription is not supported for this request.
   optional SymbolRequest symbol_request = 23;

   // Request for a list of entitlements of the current user.
   // Subscription is not supported for this request yet.
   optional shared_1.EntitlementRequest entitlement_request = 24;

   // Request contract metadata by contract ID.
   optional ContractMetadataRequest contract_metadata_request = 25;

   // Request algo strategy definitions.
   // Number of simultaneous requests in processing is limited, 100 by default.
   // Subscription is not supported for this request.
   optional AlgoStrategyDefinitionRequest algo_strategy_definition_request = 26;
}

// Report with requested information and subscription updates.
// It will contain only one report type at the same time (related to id).
message InformationReport
{
   // Report ID is equal to a corresponding request and subscription ID.
   required uint32 id = 1;

   // True means that requested data is complete at the moment, false means more report messages are expected for completeness.
   optional bool is_report_complete = 2 [default = true];

   // Optional status code for a request or subscription, status is only sent for initial status and status changes.
   enum StatusCode
   {
      /// success codes  (0 - 99)
      // Request is processed without subscription (subscription was not requested).
      SUCCESS = 0;

      // Request is processed and subscription is established.
      SUBSCRIBED = 1;

      // Subscription is dropped by a client request.
      DROPPED = 2;

      // Unsolicited information update because of subscription.
      UPDATE = 3;

      // Currently subscription is disconnect because of communication issues
      // NOTE: Clients should not resubscribe in this case, the server will restore subscription with
      // sending SUBSCRIBED status once communication issues are resolved
      DISCONNECTED = 4;

      /// failure codes (100+), subscription (if any) is dropped in case of failure.
      // General failure.
      FAILURE = 101;

      // Requested information is not found.
      NOT_FOUND = 104;

      // The request rate limit has been violated.
      REQUEST_RATE_LIMIT_VIOLATION = 105;

      // The limit of subscriptions has been violated.
      SUBSCRIPTION_LIMIT_VIOLATION = 106;

      // The limit of active requests has been violated.
      ACTIVE_REQUESTS_LIMIT_VIOLATION = 107;
   }
   // This field is associated with StatusCode enum type.
   required uint32 status_code = 3;

   // Possible details of status or failure.
   optional string text_message = 4;

   // Report with trading accounts.
   optional AccountsReport accounts_report = 5;

   // Resolved symbol initial information or update.
   optional SymbolResolutionReport symbol_resolution_report = 6;

   // Report with balances from the last statement for all authorized accounts.
   optional LastStatementBalancesReport last_statement_balances_report = 7;

   // Report with currency rates per brokerage.
   optional CurrencyRatesReport currency_rates_report = 8;

   // Report with session information.
   optional SessionInformationReport session_information_report = 9;

   // Report with a list of historical orders according to specified parameters.
   optional HistoricalOrdersReport historical_orders_report = 15;

   // Report with a list of symbols for an underlying contract.
   optional SymbolsByUnderlyingReport symbols_by_underlying_report = 16;

   // Report with a list of child symbols.
   optional ChildSymbolsReport child_symbols_report = 17;

   // Report with at-the-money strikes.
   optional AtTheMoneyStrikeReport at_the_money_strike_report = 18;

   // Report with the defined strategy metadata
   optional StrategyDefinitionReport strategy_definition_report = 19;

   // Report with session timerange information
   optional SessionTimeRangeReport session_timerange_report = 20;

   // Report with trading day timerange information
   optional TradingDayTimeRangeReport trading_day_timerange_report = 21;

   // Report with order entitlements.
   optional OrderEntitlementReport order_entitlement_report = 22;

   // Report with a symbol category tree for a particular root.
   optional SymbolCategoryListReport symbol_category_list_report = 23;
   
   // Report with a symbol category.
   optional SymbolCategoryReport symbol_category_report = 29;

   // Report with a list of found symbols.
   optional SymbolListReport symbol_list_report = 24;

   // Report with a symbol.
   optional SymbolReport symbol_report = 25;

   // Report with a list of entitlements of the current user.
   optional shared_1.EntitlementReport entitlement_report = 26;

   // Report with the requested contract metadata.
   optional ContractMetadataReport contract_metadata_report = 27;

   // Report with algo strategies definitions.
   optional AlgoStrategyDefinitionReport algo_strategy_definition_report = 28;
}

// Request for a list of accounts this user is authorized to use and/ or monitor, empty message.
message AccountsRequest
{
}

// Response with a list of authorized accounts grouped by brokerage firms and internal sales series (account groups),
// the same account can not belong to more than one account group.
message AccountsReport
{
   // List or brokerages with accounts the user works with.
   repeated Brokerage brokerage = 1;
}

// List of brokerage accounts.
message Brokerage
{
   // Brokerage firm ID in CQG trade routing system.
   required uint32 id = 1;

   // Brokerage firm name.
   required string name = 2;

   // List of sales series.
   repeated SalesSeries sales_series = 3;
}

// List of accounts in a sales series group.
message SalesSeries
{
   // Sales series number in CQG trade routing system.
   required string number = 1;

   // Sales series name.
   required string name = 2;

   // List of accounts.
   repeated Account account = 3;
}

// Trade routing account data.
message Account
{
   // Account ID in CQG trade routing system.
   required sint32 account_id = 1;

   // Account ID in Brokerage Firm.
   required string brokerage_account_id = 2;

   // Account name in CQG trade routing system.
   required string name = 3;

   // Last statement date for this account
   // (brokerage local date in time format, use date part only).
   required sint64 last_statement_date = 4;

   // True if user can only monitor this account without trading.
   optional bool is_view_only = 5;

   // True if user was unauthorized and is not able to use/ see this account anymore.
   optional bool is_unauthorized = 6;

   // Reserved field number (do not reuse).
   optional sint64 reserved1 = 7;

   // Account connection status list.
   // It is used for accounts that require additional authorization.
   enum AccountConnectionStatus
   {
      //  Route is offline, connection is impossible.
      OFFLINE = 1;

      // Connection is not established but can be initiated by a logon message.
      DISCONNECTED = 2;

      // Connection is initiated but is not fully established.
      CONNECTING = 3;

      // Connection is established, trading is possible.
      CONNECTED = 4;
   }

   // Current account connection status.
   // It is set for only accounts that require authorization.
   optional uint32 account_connection_status = 8;

   // Account status last update time.
   // It is set for only accounts that require authorization.
   optional google.protobuf.Timestamp account_connection_status_utc_timestamp = 9;

   // Optional list of authorized contributors.
   repeated string contributor_id = 10;

   // This flag shows if pre trade mid market mark should be calculated by client
   // and provided via order extra attribute "PreTradeMidMarketMark" during order placement or modification.
   optional bool pre_trade_mid_market_mark_required = 11;
}

// Request to resolve a symbol pattern or specific symbol identifier to a specific contract with optional subscription for meta-data updates.
// Symbol resolution rules:
//   a) If the requested symbol points to a symbol prefix rather than a specific contract then it is resolved into the most active contract for
//      this symbol prefix (e.g. 'EP' is resolved to 'EPU3').
//      The update is sent when an active contract is changed (e.g. the update might contain the following 'EPZ3')
//   b) If the requested symbol points to a specific contract that is expired already then status code NOT_FOUND is returned in InformationReport.
//   c) If the requested symbol points to a specific contract that is tradable right now then it is resolved to itself. Update is sent only when
//      meta-data for such contract is changed or expired. In case of expiration SymbolResolutionReport is returned with 'deleted' field set to True.
//   d) If requested symbol points to an option instrument without specific month and strike it is resolved to the lead (first non-spot) month
//      of the underlying future or its own front month if the underlying contract is not a future (e.g. 'C.EP' is resolved to 'C.EPU131600').
//      Update is sent only when the resolved option contract is expired (strike is not updated to follow underlying contract market price).
//   e) If requested symbol is a symbol prefix that follows '?N' or '??N' (where N is number, e.g. EP?2) then it is resolved to
//      Nth nearest contract.
//      N = 1 means 'front' contract, N = 2 means the nearest contract that follows the front, etc.
//      '?' and '??' are different for futures only and '?' means Nth nearest regular future and '??' means Nth nearest spot or regular future.
//      Update is sent when the front contract expired and replaced with the following contract (relative position change).
//      N = 0 is a special case that means 'most active' contract which works the same way as (a)
// NOTE: Available and active contract lists are updated within 24 hours of an expiring contract's final trading session.
//       Meta-data updates for affected contracts, when a subscription is present, are sent when the list updates occur.
//       Initial resolution requests use the same lists, so the best way to avoid inconsistency and unnecessary server load is to subscribe
//       and process updates when notified.
message SymbolResolutionRequest
{
   // Symbol pattern to resolve.
   required string symbol = 1;
}

// Symbol resolution result or update.
message SymbolResolutionReport
{
   // Resolved contract meta-data.
   required ContractMetadata contract_metadata = 1;

   // Contract is expired (used for updates).
   optional bool deleted = 2;
}

// Request for balances from the last statement for all authorized accounts.
message LastStatementBalancesRequest
{
}

// Report with balances from the last statement for all authorized accounts,
// they will be sent as a response to a corresponding request
// and after each statement processing (if subscribed).
message LastStatementBalancesReport
{
   repeated Balance balance = 1;
}

// Balance record for one of the accounts and one of the currencies (id is used as a key for updates).
// Values like OTE, UPL and MVO are from statements and won't be updated in real time but after each next statement.
// Money related values are in the specified currency.
// NOTE: There could be more then one balance for one account and one currency.
//       Not all values for a balance record are provided by all statements, it is up to Brokerage to include such values and only
//       currency and ending cash balance are required to be valid.
message Balance
{
   // Surrogate id as a key for updates.
   required sint32 id = 1;

   // Account of this balance record.
   required sint32 account_id = 2;

   // Statement date this positions is related.
   required sint64 statement_date = 3;

   // Currency code (ISO 4217 based).
   required string currency = 4;

   // Ending Cash Balance.
   required double balance = 5;

   // Total Account Value.
   required double total_value = 6;

   // Open Trade Equity for Futures.
   required double ote = 7;

   // Unrealized profit-loss.
   required double upl = 8;

   // Market Value of options.
   required double mvo = 9;

   // Cash Excess.
   required double cash_excess = 10;

   // Collateral on Deposit.
   required double collateral = 11;

   // Initial Margin Requirements.
   required double initial_margin = 12;
}

// Request for currency rates for all brokerages user's accounts belong to.
message CurrencyRatesRequest
{
}

// Report with currency rates per brokerage.
// It will be sent as a response to a corresponding request
// and after each statement processing (if subscribed).
message CurrencyRatesReport
{
   // List of rates per brokerage the user is authorized to.
   repeated BrokerageCurrencyRates brokerage_currency_rates = 1;
}

// Currency rates of one brokerage.
message BrokerageCurrencyRates
{
   // Brokerage ID.
   required uint32 brokerage_id = 1;

   // Master currency code to which rates are provided (ISO 4217 based).
   required string master_currency = 2;

   // Statement date.
   required sint64 statement_date = 3;

   // List of brokerage rates.
   repeated CurrencyRate currency_rate = 4;
}

// Rate of one currency to a master currency for the brokerage.
message CurrencyRate
{
   // Currency code (ISO 4217 based).
   required string currency = 2;

   // Exchange rate.
   required double rate = 3;

   // Number of decimals in 'rate' field.
   optional uint32 decimal_places = 4;
}

// Request for session information per instrument group.
message SessionInformationRequest
{
   // ID of a session information from contract meta-data.
   required sint32 session_info_id = 1;

   // UTC time from which session information is requested (e.g. if historical session times are necessary)
   // Current time is used by default.
   optional sint64 from_utc_time = 2;

   // UTC time up to which session information is requested (e.g. if future session times are necessary)
   // Current time is used by default. This field must not be used with subscriptions.
   optional sint64 to_utc_time = 3;
}

// Report with session information.
message SessionInformationReport
{
   // Session information ID.
   required sint32 session_info_id = 1;

   // List of session segment records.
   repeated SessionSegment session_segment = 2;
}

// Session segment record.
message SessionSegment
{
   // Session segment ID useful for updates.
   required sint64 session_segment_id = 1;

   // Session group is deleted (used for updates).
   optional bool deleted = 2;

   // UTC time from which this session information is effective (inclusive).
   // It is omitted if this session information was the same since Instrument group was introduced.
   optional sint64 from_utc_time = 3;

   // UTC time up to which this session information is effective (exclusive).
   // It is omitted if this session information is not planned yet to be changed.
   optional sint64 to_utc_time = 4;

   // Schedule for all sessions.
   repeated SessionSchedule session_schedule = 5;

   // Trading day schedule.
   repeated TradingDay trading_day = 6;

   // Daily holidays. May have some sessions interday, but daily bar is not created.
   repeated SessionHoliday daily_holiday = 7;
}

// Session schedule.
message SessionSchedule
{
   // Session name.
   required string name = 1;

   // List of session times per day of week.
   repeated SessionDay session_day = 2;

   // List of exchange specific dates when this session is closed.
   repeated SessionHoliday session_holiday = 3;

   // True if this is a primary session.
   optional bool is_primary = 4;
}

// Days of week enumeration.
enum DayOfWeek
{
   Sunday = 0;
   Monday = 1;
   Tuesday = 2;
   Wednesday = 3;
   Thursday = 4;
   Friday = 5;
   Saturday = 6;
}

// Trading day schedule.
message TradingDay
{
   // Days of week list with the same day schedule.
   repeated DayOfWeek day_of_week = 1;

   // Trading day start offset in milliseconds from 00:00 UTC.
   optional sint64 start_offset = 2;
}

// Session times per day of week.
// All time offsets are in milliseconds from 00:00 UTC time of a specific date that corresponds to specific day of week.
// Offset values are optional and can be positive and negative
// (e.g. session can be completely 'pre-open' so only pre_open_offset and post_close_offset values are set).
// NOTE: Session times may not match exact exchange schedule especially if exchange have dynamic times
// (e.g. session starts after publishing a settlement, after underlying contract trade, etc.)
// or if exchange sends market data outside of session boundaries (e.g. late trades)
message SessionDay
{
   // Days of week list with the same day schedule.
   repeated DayOfWeek day_of_week = 1;

   // Session pre-open time offset.
   optional sint64 pre_open_offset = 2;

   // Session open time offset.
   optional sint64 open_offset = 3;

   // Session close time offset.
   optional sint64 close_offset = 4;

   // Session post-close time offset.
   optional sint64 post_close_offset = 5;
}

// Session holiday record.
message SessionHoliday
{
   // Date of a holiday.
   required sint64 holiday_date = 1;

   // Name of a holiday.
   required string holiday_name = 2;
}

// Request a list of symbols (options) by an underlying contract
message SymbolsByUnderlyingRequest
{
   required uint32 underlying_contract_id = 1;
}

// Report with a list of symbols.
// When the list is updated by a subscription
// (e.g. some option maturity is expired or a new one appears)
// the list includes only new or deleted symbols.
message SymbolsByUnderlyingReport
{
   // List of related symbols (option maturities without strikes)
   repeated Symbol symbol = 1;
}

// Request a list of child symbols for a higher level symbol.
message ChildSymbolsRequest
{
   // Can be either id of the parent symbol or instrument group's name (for futures only, e.g. 'F.US.EP').
   required string parent_symbol_id = 1;

   // Optional filter by categories.
   repeated string category_id = 2;
}

// Report with a list of child symbols.
message ChildSymbolsReport
{
   // List of child symbols.
   repeated Symbol symbol = 1;
}

// Request at-the-money strike for the option maturity
message AtTheMoneyStrikeRequest
{
   // Option maturity symbol id representing the parent symbol for the option strike list of the same underlying and maturity period (see Symbol.id).
   required string option_maturity_symbol_id = 1;
}

// Report with at-the-money strikes.
message AtTheMoneyStrikeReport
{
   // Option at-the-money strike.
   // It is omitted if at-the-money strike cannot be calculated at the moment (e.g. due to lack of real time data).
   optional sint32 strike = 1;
}

// Request for session open/close times.
message SessionTimeRangeRequest
{
   // ID of a session information from contract meta-data.
   required sint32 session_info_id = 1;

   // Exactly two of the next three fields have to be set:
   // UTC time of start of the time range to get information for.
   // Sessions with post-close time > from_utc_time are returned.
   optional sint64 from_utc_time = 2;

   // UTC time of end of the time range to get information for.
   // Sessions with pre-open time < to_utc_time are returned.
   optional sint64 to_utc_time = 3;

   // Number of session timeranges to return.
   // If used with from_utc_time then it is the number of timeranges to return starting from that time.
   // If used with to_utc_time then it is the number of timeranges to return preceding that time.
   optional uint32 count = 4;
}

// This may come in multiple chunks if many items are reported.
message SessionTimeRangeReport
{
   // Session open/close times.
   repeated SessionTimeRange session_time_ranges = 1;

   // Request was done for the range that was too long, so it was truncated.
   optional bool truncated = 2;
}

// Session open/close times and trading day date.
message SessionTimeRange
{
   // UTC time of session pre-open.
   required sint64 pre_open_utc_time = 1;

   // UTC time of session open.
   required sint64 open_utc_time = 2;

   // UTC time of session close.
   required sint64 close_utc_time = 3;

   // UTC time of session post close.
   required sint64 post_close_utc_time = 4;

   // Trading date the session belongs to, local to exchange, time part is not used (set to 00:00).
   required sint64 trade_date = 5;

   // Session name.
   required string session_name = 6;
}

// Request for trading day open/close times.
message TradingDayTimeRangeRequest
{
   // ID of a session information from contract meta-data.
   required sint32 session_info_id = 1;

   // True if holidays should be included in the response.
   optional bool include_holidays  = 2;

   // Exactly two of the next three fields have to be set:
   // UTC time of start of the time range to get information for.
   // Trading days with end time > from_utc_time are returned.
   optional sint64 from_utc_time = 3;

   // UTC time of end of the time range to get information for.
   // Trading days with start time < to_utc_time are returned.
   optional sint64 to_utc_time = 4;

   // Number of trading day timeranges to return.
   // If used with from_utc_time then it is the number of timeranges to return starting from that time.
   // If used with to_utc_time then it is the number of timeranges to return preceding that time.
   optional uint32 count = 5;
}

// This may come in multiple chunks if many items are reported.
message TradingDayTimeRangeReport
{
   // Trading day start/end times.
   repeated TradingDayTimeRange trading_day_time_ranges = 1;

   // Request was done for the range that was too long, so it was truncated.
   optional bool truncated = 2;
}

// Trading day start/end times and date.
message TradingDayTimeRange
{
   // Trading date, local to exchange, time part is not used (set to 00:00).
   required sint64 trade_date = 1;

   // The next two fields are not present for holidays,
   // because thereâs no trading day for these dates, hence no start and end times.
   // UTC time of trading day start (first session pre-Open time).
   optional sint64 start_utc_time = 2;

   // UTC time of trading day end (last session post-Close time).
   optional sint64 end_utc_time = 3;
}

// Request for algo strategies definitions.
message AlgoStrategyDefinitionRequest
{
   // List of algo strategies to request definitions (abbreviations).
   repeated string algo_strategy = 1;
}

// Report with algo strategies definitions.
message AlgoStrategyDefinitionReport
{
   // List of algo strategy definitions for given abbreviations.
   repeated AlgoStrategyDefinition algo_strategy_definition = 1;
}

// Algo strategy definition.
message AlgoStrategyDefinition
{
   // Algo strategy abbreviation.
   optional string abbreviation = 1;

   // Algo strategy definition. Contains FIXatdl document that describes the list of parameters, their types and some UI specifics.
   optional string definition = 2;
}

// Symbol structure
message Symbol
{
   // Symbol Identifier.
   required string id = 1;

   // Symbol readable name.
   required string name = 2;

   // Symbol description.
   required string description = 3;

   // CFI code (Classification of Financial Instruments, ISO 10962) if appropriate.
   optional string cfi_code = 4;

   // True if this symbol has child symbols (false for leafs of the symbol tree).
   optional bool has_child_symbols = 5;

   // Contract meta-data if a symbol is a specific contract (leaf of the symbol tree).
   optional ContractMetadata contract_metadata = 6;

   // Deleted flag is used in updates when the symbol is removed (e.g. expired)
   optional bool deleted = 7;

   // Last trading date for derivatives if applicable.
   // (local exchange date in time format, use date part only).
   optional sint64 last_trading_date = 8;

   // Month letter and 2-digit year identifying the maturity month of the symbol.
   // Note: look at comment for maturity_month_year from ContractMetadata for further info.
   optional string maturity_month_year = 9;

   // Name of a group of symbols that share the same properties (e.g. commodity name for futures and options)
   optional string instrument_group_name = 10;

   // ID of the parent symbol (if this is not the root symbol - product).
   optional string parent_symbol_id = 11;

   // List of categories of this symbol, if any.
   repeated string category_id = 12;

   // If this is a double-quoted product then a source symbol ID is included.
   optional string source_symbol_id = 13;

   // Meta-data of a product if this symbol describes one (aka Symbol Root Key).
   optional ProductMetadata product_metadata = 14;

   // Meta-data of a security if this symbol describes one (aka Symbol Prefix Key)
   optional SecurityMetadata security_metadata = 15;

   // Meta-data of options maturity group if this symbol describes one (aka Option Lead Key)
   optional OptionMaturity option_maturity_metadata = 16;
}

message ProductMetadata
{
   optional string product_id = 1;
}

message SecurityMetadata
{
   optional string security_id = 1;

   // CFI code (Classification of Financial Instruments, ISO 10962).
   optional string cfi_code = 2;

   // Contract currency code (ISO 4217 based).
   optional string currency = 3;

   // Size or a single market tick in correct price format.
   optional double tick_size = 4;

   // Symbol tick money value in the symbol's currency.
   optional double tick_value = 5;

   // Period type. This field is associated with PeriodType enum type.
   optional uint32 period_type = 6;

   // Period value in period_type units.
   optional uint32 period_value = 7;

   // Contract size in the number of units (where defined). Unit is defined by contract_size_unit filed.
   optional cqg.Decimal contract_size_in_units = 8;

   // Unit label for the contract size.
   optional shared_1.Text contract_size_unit = 9;

   // Optional custom symbol parameters per associated contributor (if any).
   repeated metadata_1.ContributorParameters contributor_parameters = 10;

   // ID of the symbol the security represents (Symbol.id attribute)
   optional string symbol_id = 11;
}

message OptionMaturity
{
   optional string option_maturity_id = 1;
}

// Request to define a strategy as a contract
message StrategyDefinitionRequest
{
   // Strategy to define.
   required StrategyDefinition strategy_definition = 1;
}

// Report of the contract metadata assigned to the strategy.
message StrategyDefinitionReport
{
   // Assigned strategy metadata.
   required ContractMetadata contract_metadata = 1;
}

// Symbol category.
message SymbolCategory
{
   // Category identifier.
   required string id = 1;

   // Category name.
   required string name = 2;

   // Category description.
   optional string description = 3;

   // Category parent identifier. Omitted for root categories.
   optional string parent_id = 4;

   // Indicates whether this category can be used as a filter for getting a list of symbols.
   required bool can_filter = 5;

   // If the category is an exchange then this field defines exchange ID.
   optional sint32 exchange_id = 6;

   // If the category is a contributor then this field defines contributor ID.
   optional string contributor_id = 7;

   // Deleted flag is used in updates when the category is removed.
   optional bool deleted = 8;
}

// Request for a symbol category [sub-]tree for a particular root. each category can have a list of sub-categories.
// A list of roots can be requested using an empty list of category IDs.
message SymbolCategoryListRequest
{
   // Category Identifier to request corresponding sub-tree.
   // Do not specify category ID to get categories from roots.
   optional string category_id = 1;

   // Optional depth. One level is returned if not specified.
   optional uint32 depth = 2;
}

// Report with a symbol category tree for a particular root.
message SymbolCategoryListReport
{
   // List of categories linked to their parents.
   repeated SymbolCategory symbol_category = 1;
}

// Request for a specific category by ID.
message SymbolCategoryRequest
{
   // Category Identifier to request corresponding category.
   optional string category_id = 1;
}

// Report with a category.
message SymbolCategoryReport
{
   optional SymbolCategory symbol_category = 1;
}

// Request for a list of symbols according to a filter.
// At least one filter field has to be specified.
message SymbolListRequest
{
   // Category filtering. Only symbols that belong to all of the specified categories are returned.
   repeated string category_id = 1;

   // Number of levels in the symbol tree to return, one is returned if omitted.
   optional uint32 depth = 2;
}

// Report with a list of found symbols.
message SymbolListReport
{
   // List of symbols.
   repeated Symbol symbol = 1;
}

// Request for a specific symbol by ID.
message SymbolRequest
{
   // ID of a symbol to request.
   required string symbol_id = 1;
}

// Report with a symbol.
message SymbolReport
{
   optional Symbol symbol = 1;
}

// Request contract metadata by contract ID.
message ContractMetadataRequest
{
   // contract ID to request the metadata.
   required uint32 contract_id = 1;
}

// Report with the requested contract metadata.
message ContractMetadataReport
{
   // Requested metadata if successfully found.
   optional ContractMetadata contract_metadata = 1;
}

// Request of order entitlements.
message OrderEntitlementRequest
{
   // Server side contract id.
   required uint32 contract_id = 1;

   // Account ID in CQG trade routing system.
   required sint32 account_id = 2;
}

// Report with order entitlements.
message OrderEntitlementReport
{
   // Set of order entitlements.
   repeated OrderEntitlement order_entitlement = 1;
}

// Entitlements for order.
// For future compatibility unknown order types/durations/execution instructions should be ignored.
message OrderEntitlement
{
   // Order type.
   // This field is associated with Order.OrderType enum type.
   required uint32 order_type = 1;

   // Value indicating whether order_type may be executed synthetically by CQG.
   // E.g. if is_synthetic is true and order_type is MKT, it means that there will be synthetic processing
   // of Market order by CQG before the order is sent to the exchange, where Market order is not natively supported.
   // This is an informational field. The Client cannot specify this field in an order.
   required bool is_synthetic = 2;

   // Order duration.
   // This field is associated with Order.Duration enum type.
   required uint32 duration = 3;

   // Order execution instruction.
   // This field is associated with Order.ExecInstruction enum type.
   required uint32 exec_instruction = 4;

   // Whether the algo strategy is required to be set for the order.
   optional bool algo_strategy_required = 5;

   // List of algo strategies enabled for the order (abbreviations).
   repeated string algo_strategy = 6;
}

////------------------------------------------
//// Trade Routing messaging


//// Messages for accounts that require separate authorization process.
// Only one request per account is allowed for simultaneous processing.

// Account level Logon Request. One-step logon procedure.
message AccountLogon
{
   // Account ID in CQG trade routing system.
   required sint32 account_id = 1;

   // User login name for this account.
   required string username = 2;

   // User's password for this account.
   required string password = 3;
}

// Account level Logon result.
message AccountLogonResult
{
   // Account ID in CQG trade routing system.
   required sint32 account_id = 1;

   enum ResultCode
   {
      //// success codes
      // User is logged in to the system. Account connection status becomes CONNECTED.
      SUCCESS = 0;

      // Account password change required after the first logon of new account.
      // Account connection status remains CONNECTING.
      PASSWORD_CHANGE_REQUIRED = 1;

      // Account password expired. Account connection status remains CONNECTING.
      PASSWORD_EXPIRED = 2;

      //// failure codes (100+), account connection status is reset to DISCONNECTED.
      // General failure.
      FAILURE = 101;
   }

   // One of the logon result codes.
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // Optional logon result message for failure details.
   optional shared_1.Text text_message = 3;

   // Time when the message was sent.
   required google.protobuf.Timestamp server_utc_timestamp = 4;
}

// Account level password change request.
message AccountPasswordChange
{
   // Account ID in CQG trade routing system.
   required sint32 account_id = 1;

   // Currently used password.
   required string old_password = 2;

   // New password that user wants to use.
   required string new_password = 3;
}

// Account level password change result.
message AccountPasswordChangeResult
{
   // Account ID in CQG trade routing system.
   required sint32 account_id = 1;

   // Password change result.
   enum ResultCode
   {
      /// success codes
      // User password is changed successfully.
      SUCCESS = 0;

      /// failure codes (100+)
      // Most likely incorrect user name or password.
      FAILURE = 101;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // Optional failure details.
   optional shared_1.Text text_message = 3;
}

// Account level Logoff request.
message AccountLogoff
{
   // Account ID in CQG trade routing system.
   required sint32 account_id = 1;
}

// Account level Logoff result.
message AccountLogoffResult
{
   // Account ID in CQG trade routing system.
   required sint32 account_id = 1;

   // Logoff result.
   enum ResultCode
   {
      /// success codes
      // Logoff was successful.
      SUCCESS = 0;

      /// failure codes (100+)
      // Logoff failed.
      FAILURE = 101;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // Optional failure description.
   optional shared_1.Text text_message = 3;

   // Time when the message was sent.
   required google.protobuf.Timestamp server_utc_timestamp = 4;
}


// Subscription to trade routing data and notifications about trading information updates.
// Client can be subscribed to several publications.
// If some account is subscribed by several publications then client will receive a separate snapshot per subscription
// but one real time update with a list of subscriptions.
message TradeSubscription
{
   // ID of a subscription that should be unique enough to match responses and updates with corresponding requests.
   required uint32 id = 1;

   // Scope of the subscription (provide a list).
   enum SubscriptionScope
   {
      // Subscribe to order updates.
      ORDERS = 1;

      // Subscribe to open positions and matched trades updates.
      POSITIONS = 2;

      // Subscribe to collateral updates (current margin and purchasing power).
      COLLATERAL = 3;
   }
   // This field is associated with SubscriptionScope enum type.
   repeated uint32 subscription_scope = 2;

   // Type of the publication to subscribe.
   enum PublicationType
   {
      // Subscribe to a single account.
      ACCOUNT = 1;

      // Subscribe to all accounts of a specific sales series.
      SALES_SERIES = 2;

      // Subscribe to all accounts of a specific brokerage.
      BROKERAGE = 3;

      // Subscribe to all accounts this user is authorized for (default).
      ALL_AUTHORIZED = 4;
   }
   // This field is associated with PublicationType enum type.
   optional uint32 publication_type = 3;

   // Account ID when publicationType = ACCOUNT.
   optional uint32 account_id = 4;

   // Sales series number when publicationType = SALES_SERIES.
   // Note: sales_series_number might be not enough to find specific sales series,
   // so brokerage_id is needed to be specified as well.
   optional string sales_series_number = 5;

   // Brokerage ID when publicationType = BROKERAGE or SALES_SERIES.
   optional uint32 brokerage_id = 6;

   // True to subscribe, false to unsubscribe (only id value is used to unsubscribe).
   required bool subscribe = 7;

   // Optionally limit request to receive information about orders that were updated/ added after specified server related time (inclusive).
   // It is used to reduce amount of information necessary to send after re-connection.
   // Client should set this time equal to the last received order status time ('status_utc_time' field) in UTC to avoid gaps and
   // be ready for duplicates that have to be detected by corresponding IDs.
   // Note: use last_order_update_utc_timestamp field instead.
   optional sint64 last_order_update_utc_time = 8 [deprecated = true];

   // Optionally limit request to receive information about orders that were updated/ added after specified server related time (inclusive).
   // It is used to reduce amount of information necessary to send after re-connection.
   // Client should set this time equal to the last received order status time ('status_utc_time' field) in UTC to avoid gaps and
   // be ready for duplicates that have to be detected by corresponding IDs.
   // If specified it's used instead of last_order_update_utc_time field.
   optional google.protobuf.Timestamp last_order_update_utc_timestamp = 14;

   // True means sending only real time data and skip sending an initial orders snapshot, send initial snapshot otherwise.
   // NOTE: do not set this attribute after restoring session since some events might be missed to be delivered,
   // use last_order_update_utc_time instead.
   optional bool skip_orders_snapshot = 9;

   // True means sending only FCM confirmed positions and their updates (if subscribed)
   // without matching with current day fills, send matched net positions otherwise.
   optional bool confirmed_positions_only = 10;

   // Positions matching algorithm (for position subscription).
   enum MatchingAlgorithm
   {
      // First In, First Out. The first order filled is the first order offset when an order on the opposite side of the market is executed.
      FIFO = 1;

      // High Buy, High Sell. The highest buy is matched with the highest sell.
      HBHS = 2;

      // Last In, First Out. The last order filled is the first order offset when an order on the opposite side of the market is executed.
      LIFO = 3;
   }
   // This field is associated with MatchingAlgorithm enum type.
   // FIFO is used if omitted.
   // Applicable only for contracts with ContractMetadata.position_tracking = NET_POSITION.
   // For other contract types it is always FIFO.
   optional uint32 matching_algorithm = 11;

   // If true or omitted then intraday trades are matched first and then intraday leftover is matched against previous close positions.
   // If false then previous day open positions and intraday fills are matched in a single pass.
   // Applicable only for contracts with ContractMetadata.position_tracking = NET_POSITION.
   // For other contract types it is always false.
   optional bool match_intraday_first = 12;

   // This field is associated with MatchingAlgorithm enum type.
   // Historical positions Matching algorithm. The same as matching_algorithm if omitted.
   // It is ignored if match_intraday_first is false.
   // Applicable only for contracts with ContractMetadata.position_tracking = NET_POSITION.
   optional uint32 historical_matching_algorithm = 13;

}

// Server status for a trade subscription.
// It is sent before or along with a snapshot of initial status information.
message TradeSubscriptionStatus
{
   // Subscription Id this result is sent for.
   required uint32 id = 1;

   // Possible result codes.
   enum StatusCode
   {
      // success codes (0 - 99)
      SUCCESS = 0;

      // Currently subscription is [partially] disconnect because of communication issues
      // NOTE: Clients should not resubscribe in this case, the server will restore subscription with
      // sending SUCCESS status once communication issues are resolved following with all necessary data updates
      DISCONNECTED = 1;

      // failure codes (100+)
      FAILURE = 101;

      // The limit of the subscriptions has been violated.
      SUBSCRIPTION_LIMIT_VIOLATION = 102;

      // Unknown or ambiguous account, sales series number, or brokerage id in the subscription
      INVALID_PUBLICATION_ID = 103;

      // The limit of subscribed accounts has been violated.
      SUBSCRIBED_ACCOUNTS_LIMIT_VIOLATION = 104;
   }
   // Subscription result.
   // This field is associated with StatusCode enum type.
   required uint32 status_code = 2;

   // Optional details.
   optional string text_message = 3;
}

// Indicator that a snapshot of requested information is delivered and corresponding data is complete.
message TradeSnapshotCompletion
{
   // ID of a corresponding trade subscription.
   required uint32 subscription_id = 1;

   // List of subscription scopes whose snapshots are completed.
   // Completion message for one scope is sent only once but they can be combined
   // (e.g. one completion message might come for ORDERS and another one later for POSITIONS and COLLATERAL).
   // This field is associated with TradeSubscription.SubscriptionScope enum type.
   repeated uint32 subscription_scope = 2;
}

// MiFID algorithm ID type.
enum MiFIDAlgorithmIdType
{
   // External MiFID Algo ID, an explicit value to be sent as-is to the execution system.
   // Non-CQG WebAPI clients should always use this type.
   EXTERNAL_MIFID_ALGO_ID = 1;

   // CQG internal MiFID Algo ID.
   CQG_MIFID_ALGO_ID = 2;
}

// MiFID investment decision ID type.
enum MiFIDInvestmentDecisionIdType
{
   // Trader MiFID short code.
   EXTERNAL_TRADER_ID = 1;

   // External MiFID Algo ID, an explicit value to be sent as-is to the execution system.
   EXTERNAL_ALGO_ID = 2;

   // CQG internal MiFID Algo ID.
   CQG_ALGO_ID = 3;
}

// One of the order related requests. There must be only one optional order submessage specified per request.
// E.g NewOrder, but not NewOrder and CancelOrder.
message OrderRequest
{
   // ID of a request that should be unique enough to match with possible OrderRequestReject.
   required uint32 request_id = 1;

   // New order request (place order).
   optional NewOrder new_order = 2;

   // Modify order request.
   optional ModifyOrder modify_order = 3;

   // Cancel order request.
   optional CancelOrder cancel_order = 4;

   // Cancel all orders request.
   optional CancelAllOrders cancel_all_orders = 14;

   // Liquidate all open positions.
   optional LiquidateAll liquidate_all = 20;

   // Cancel all orders and liquidate all open positions.
   optional GoFlat go_flat = 21;

   // Suspend (park) order.
   optional SuspendOrder suspend_order = 10;

   // Activate suspended (parked) order.
   optional ActivateOrder activate_order = 5;

   // Modify order's user attributes.
   optional ModifyUserAttributes modify_user_attributes = 6;

   // New compound order request (place compound order).
   optional NewCompoundOrder new_compound_order = 8;

   // Synthetic hangup liquidation with a MKT order.
   optional SyntheticLiquidate synthetic_liquidate = 11;

   // Synthetic hangup liquidation with a LMT order.
   optional SyntheticScratch synthetic_scratch = 12;

   // Modify a synthetic order to get an immediate fill.
   optional GoMarket go_market = 13;

   // Username of the user on whose behalf the order request is being sent.
   optional string on_behalf_of_user = 7;

   // Regulatory Algorithm ID for client algorithm associated with this order, if any.
   // This field is applicable only for exchanges that use it, e.g. Eurex.
   // TransactionStatus message echoes back the value from the latest order request
   optional uint32 client_regulatory_algorithm_id = 9;

   // MiFID algorithm ID for this order, contents depend on mifid_algorithm_id_type.
   // Provide only when the order must have an algorithm as Execution Within Firm under MiFID II definitions.
   optional string mifid_algorithm_id = 15;

   // The type of mifid_algorithm_id supplied. One of MiFIDAlgorithmIdType enum.
   optional uint32 mifid_algorithm_id_type = 16;

   // True instructs server to send this order as Execution Within Firm=CLIENT/NORE
   // rather than the user's server-side configured trader short code.
   optional bool override_execution_within_firm_with_nore = 17 [default = false];

   // MiFID investment decision ID for this order, contents depend on mifid_investment_decision_id_type.
   optional string mifid_investment_decision_id = 18;

   // The type of mifid_investment_decision_id supplied. One of MiFIDInvestmentDecisionIdType enum.
   optional uint32 mifid_investment_decision_id_type = 19;
}

// Low-level order request reject. It is sent only if direct order status updates are impossible.
message OrderRequestReject
{
   // ID of the order request this reject corresponds to.
   required uint32 request_id = 1;

   // Reject code. The list is provided separately.
   required uint32 reject_code = 2;

   // Optional reject details message.
   optional string text_message = 3;
}

// New order request.
message NewOrder
{
   // Order to place.
   required Order order = 1;

   // True if order should be suspended (parked) and wait a separate activate request or activation time.
   optional bool suspend = 2;
}

// Specifies what kind of strategy an order, a trade or a position belongs to
enum SpeculationType
{
   // Speculation strategy.
   SPECULATION = 1;

   // Arbitrage strategy.
   ARBITRAGE = 2;

   // Hedging strategy.
   HEDGE = 3;
}

// Trade routing order. It is used as new order request and as a part of order status updates.
message Order
{
   enum Side
   {
      // Describes purchasing side of a trade.
      BUY = 1;

      // Describes selling side of a trade.
      SELL = 2;
   }

   enum OrderType
   {
      // Market order, buy or sell by the best available opposite price.
      MKT = 1;

      // Limit order, buy or sell by price that is the same or better then specified limit price.
      LMT = 2;

      // Stop order, Order becomes a Market when market reaches order's stop price
      // (which is on opposite side of market).
      STP = 3;

      // Stop-limit order, Order becomes a Limit when market reaches order's stop price.
      STL = 4;
   }

   enum ExecInstruction
   {
      // All or None (fill order only completely).
      AON = 1;

      // Iceberg (show only part of order size).
      ICEBERG = 2;

      // Quantity triggered (aka DOM Triggered, honor additional quantity threshold for triggering).
      QT = 3;

      // Trailing order (price of the order is following market one direction by specific offset).
      TRAIL = 4;

      // Funari (Limit order becomes a Market on Close).
      FUNARI = 5;

      // Market if Touched (Limit order becomes a Market when market reaches order's limit price).
      MIT = 6;

      // Market Limit Market is a limit order that is used to place a buy order above the best offer
      // to fill by the best offer or a sell order below the best bid to fill by the best bid.
      MLM = 7;

      // Post-only order. Ensures the limit order will be added to the order book and not match with
      // a pre-existing order
      POSTONLY = 8;

      // Order with discretionary price offset (used along with Order.discretionary_offset).
      DISCRETION = 9;

      // Market with leftover as Limit (market order then unexecuted quantity becomes limit order at last price).
      MTL = 10;

      // An auction order is an order to buy or sell in the market at the Calculated Opening Price (COP).
      // Unmatched auction orders are converted to limit orders on the market open.
      AUCTION = 11;

      // None (this means "plain order without any exec instructions").
      // This value shall not be explicitely provided in OrderRequest.
      NONE = 12;
   }

   enum Duration
   {
      // Day order. Order is working through the current trading day only.
      DAY = 1;

      // Good Til Canceled. Order is working until canceled or until the contract is no longer available for trading.
      GTC = 2;

      // Good Til Date. Order is working until the end of the nearest trading day for the contract on
      // or before the date specified in the order.
      GTD = 3;

      // Good Til Time. Order is working until the specified time.
      GTT = 4;

      // Fill and Kill. Immediately fill as many as possible and cancel the rest.
      FAK = 5;

      // Fill Or Kill. Immediately fill this order completely or cancel.
      FOK = 6;

      // At The Open. Buy or sell at the very beginning of the trading day.
      ATO = 7;

      // At The Close. Buy or sell at the close of the market, or as near to the closing price as possible.
      ATC = 8;
   }

   enum TrailingPeg
   {
      // Trail the best bid.
      BESTBID = 1;

      // Trail the best ask.
      BESTASK = 2;

      // Trail the last trade.
      LASTTRADE = 3;
   }

   // Specifies what the order is intended to do: open (or extend) a position on the same side as the order or close (or reduce) an opposite position.
   // Applicable only for contracts with position_tracking either LONG_SHORT_WITH_IMPLIED_CLOSE or LONG_SHORT_WITH_EXPLICIT_CLOSE.
   enum OpenCloseInstruction
   {
      // Opening a new today position.
      OPEN = 1;

      // Closing or reducing (today only if ContractMetadata.position_tracking is LONG_SHORT_WITH_EXPLICIT_CLOSE,
      // today or yesterday if LONG_SHORT_WITH_IMPLIED_CLOSE).
      CLOSE = 2;

      // Closing or reducing a yesterday position (if ContractMetadata.position_tracking is LONG_SHORT_WITH_EXPLICIT_CLOSE).
      CLOSE_YESTERDAY = 3;
   }

   // Id of an account that is/ was used to place an order.
   required sint32 account_id = 1;

   // Client side time when an order was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 2 [deprecated = true];

   // Client side time when an order was submitted (UTC).
   // If specified by the user it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 27;

   // Server side contract Id of the order (see ContractMetadata message).
   required uint32 contract_id = 3;

   // Client order identifier, must be unique within a single trading day for day orders and across days for multi-day orders.
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Order type.
   // This field is associated with OrderType enum type.
   required uint32 order_type = 5;

   // List of applicable execution instructions.
   // This field is associated with ExecInstruction enum type.
   repeated uint32 exec_instruction = 6;

   // Order duration.
   // This field is associated with Duration enum type.
   required uint32 duration = 7;

   // Date for GTD (local to exchange, date only value in time format) when the order should expire.
   optional sint64 good_thru_date = 8;

   // Order side.
   // This field is associated with Side enum type.
   required uint32 side = 9;

   // Limit price of the order (required for Limit and Stop-limit orders).
   optional sint64 scaled_limit_price = 10;

   // Stop price of the order (required for Stop and Stop-limit orders).
   optional sint64 scaled_stop_price = 11;

   // Note: use qty field instead.
   optional uint32 uint32_qty = 12 [deprecated = true];

   // Note: use visible_qty field instead.
   optional uint32 uint32_visible_qty = 13 [deprecated = true];

   // Note: use min_visible_qty field instead.
   optional uint32 uint32_min_visible_qty = 14 [deprecated = true];

   // Total positive size of the order.
   optional cqg.Decimal qty = 34;

   // Visible size of the order for Icebergs.
   optional cqg.Decimal visible_qty = 35;

   // Minimum visible positive size of the order
   // used for iceberg orders with 'random visible size',
   // must be < visible_qty.
   optional cqg.Decimal min_visible_qty = 36;

   // True if this is a manual order (order placed by the user direct action), automated otherwise.
   required bool is_manual = 15;

   // True if order is used for closing/ reducing a position, opening/ increasing otherwise
   // (omit this field if there is no need to be explicit). Deprecated, refer to open_close_instruction.
   optional bool is_close = 16 [deprecated = true];

   // True if the order is aggressive (Fixed Income specific order modifier).
   optional bool is_aggressive = 17;

   // Maximum offset between market and limit prices for trail orders.
   optional sint32 scaled_trail_offset = 18;

   // Trailing peg to follow specific side of the market (for limit orders only).
   // This field is associated with TrailingPeg enum type.
   // Note: order request is rejected if this field is set for stop or stop-limit order.
   optional uint32 trailing_peg = 19;

   // Note: use trigger_qty instead.
   optional uint32 uint32_trigger_qty = 20 [deprecated = true];

   // Trigger quantity (threshold) as additional stop order activation condition.
   optional cqg.Decimal trigger_qty = 37;

   // Time when order should be submitted to execution system as assigned by client (UTC).
   // Note: use activation_utc_timestamp field instead.
   optional sint64 activation_utc_time = 21 [deprecated = true];

   // Time when order should be submitted to execution system as assigned by client (UTC).
   // If specified by the user it's used instead of activation_utc_time field.
   optional google.protobuf.Timestamp activation_utc_timestamp = 28;

   // Time when order should be suspended (parked) (UTC).
   // Note: use suspension_utc_timestamp field instead.
   optional sint64 suspension_utc_time = 22 [deprecated = true];

   // Time when order should be suspended (parked) (UTC).
   // If specified by the user it's used instead of suspension_utc_time field.
   optional google.protobuf.Timestamp suspension_utc_timestamp = 29;

   // User specific attributes.
   // Only printable ASCII characters are allowed in "name" and "value" fields including 0-9A-Za-z, punctuation.
   // (ASCII character set used by the "C" locale with codes greater than 0x1f (US), except 0x7f (DEL).)
   // Violation of the fields formatting leads to rejection of requests that contain UserAttribute.
   // Note that despite punctuation is allowed, it can cause issues with 3rd party tools and formats like CSV.
   // Order comment is provided for an order via UserAttribute with "name" set to "comment" and "value" set to
   // the order comment. Depending on order route, a limit on order comment length can be imposed.
   // If that limit is exceeded, order comment is skipped, but order is not rejected.
   repeated UserAttribute user_attribute = 23;

   // List of order extra attributes.
   // Such attributes are used for Pre-Trade Mid-Market Mark, Algo Strategies and other purposes.
   repeated shared_1.NamedValue extra_attribute = 38;

   // Case-sensitive identifier (abbreviation) of algorithm used to execute the order (e.g. VWAP, TWAP, etc.)
   optional string algo_strategy = 39;

   // Date and time for GTT order (UTC) when the order should expire.
   // Note: use good_thru_utc_timestamp field instead.
   optional sint64 good_thru_utc_time = 24 [deprecated = true];

   // Date and time for GTT order (UTC) when the order should expire.
   // If specified by the user it's used instead of good_thru_utc_time field.
   optional google.protobuf.Timestamp good_thru_utc_timestamp = 30;

   // Flag used by the client for marking the user attributes checked/unchecked.
   optional bool is_user_attribute_checked = 25 [default = true];

   // Synthetic strategy trading parameters, applicable only if contract_id designates a synthetic strategy.
   // If the parameter is not applicable for the order the default value is used.
   optional StrategyTradingParameters strategy_trading_parameters = 26;

   // Specifies what the order is intended to do: open or close (reduce) a position. One of OpenCloseInstruction enum.
   // Applicable only if ContractMetadata.position_tracking is either LONG_SHORT_WITH_IMPLIED_CLOSE or LONG_SHORT_WITH_EXPLICIT_CLOSE.
   optional uint32 open_close_instruction = 31;

   // Speculation type of the order. One of SpeculationType enum.
   optional uint32 speculation_type = 32;

   // Discretionary offset in the number of discretionary ticks (used along with DISCRETION Order.exec_instruction value).
   optional uint32 discretionary_offset = 33;

   // Optional contributor involved into the order processing.
   optional string contributor_id = 40;

   // FIA Execution Source Code value for the placement.
   // Overrides the value CQG would otherwise automatically assign to the operation based on trader-account configuration.
   // Refer to https://fia.org/sites/default/files/FIA%20Revised%20Guidelines%20for%20Execution%20Source%20Code%20V1.4.2%20-%20final.pdf
   // Possible values:
   // W â Desk
   // Y â Electronic (Default)
   // C â Vendor-provided Platform billed by Executing Broker
   // G - Sponsored Access via Exchange API or FIX provided by Executing Broker
   // H - Premium Algorithmic Trading Provider billed by Executing Broker
   // D - Other, including Other-provided Screen
   optional string execution_source_code = 41;
}

// User defined attribute.
message UserAttribute
{
   // Attribute name.
   required string name = 1;

   // Attribute value (optional for modification if attribute is deleted).
   optional string value = 2;

   // True if attribute has to be deleted during modify operation.
   optional bool deleted = 3;
}

// Synthetic strategy order's outright properties.
message SyntheticStrategyProperties
{
   // Synthetic strategy trading parameters.
   optional StrategyTradingParameters strategy_trading_parameters = 1;

   // Parent synthetic order id that led to this order's (automatic) placement;
   // allows client to show the link to user.
   // Note: this is the original synthetic order's ID (OrderStatus.order_id), not affected by any modifications.
   optional string origin_order_id = 2;

   // Id of the originally placed by trader root synthetic strategy order (The same as origin_order_id for the root immediate legs).
   optional string root_order_id = 3;

   // Node index of the synthetic order (specified by root_order_id);
   // allows client to associate this order with a particular node of the synthetic strategy (either a leg or a nested strategy).
   // LegDefinition.node_index or StrategyDefinition.node_index value.
   optional uint32 node_index = 4;
}

// Modify order request, include only fields that are supposed to be modified.
message ModifyOrder
{
   // Order id assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // This client order ID of the order to modify.
   required string orig_cl_order_id = 3;

   // Client order ID of this modify request (will become new client order Id if modify is accepted).
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 5 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 18;

   // Note: use qty field instead.
   optional uint32 uint32_qty = 6 [deprecated = true];

   // Note: use visible_qty field instead.
   optional uint32 uint32_visible_qty = 7 [deprecated = true];

   // Note: use min_visible_qty field instead.
   optional uint32 uint32_min_visible_qty = 8 [deprecated = true];

   // Order size what the client wants the total size to become.
   optional cqg.Decimal qty = 23;

   // What the client wants the visible size to become.
   optional cqg.Decimal visible_qty = 24;

   // What the client wants the minimum visible size to become.
   optional cqg.Decimal min_visible_qty = 25;

   // What the client wants the limit price to become.
   optional sint64 scaled_limit_price = 9;

   // What the client wants the stop price to become.
   optional sint64 scaled_stop_price = 10;

   // What the client wants the activation time to become (UTC).
   // Note: use activation_utc_timestamp field instead.
   optional sint64 activation_utc_time = 11 [deprecated = true];

   // What the client wants the activation time to become (UTC).
   // If specified it's used instead of activation_utc_time field.
   optional google.protobuf.Timestamp activation_utc_timestamp = 19;

   // True if activation time should be removed.
   optional bool remove_activation_time = 12;

   // What the client wants the suspension time to become (UTC).
   // Note: use suspension_utc_timestamp field instead.
   optional sint64 suspension_utc_time = 13 [deprecated = true];

   // What the client wants the suspension time to become (UTC).
   // If specified it's used instead of suspension_utc_time field.
   optional google.protobuf.Timestamp suspension_utc_timestamp = 20;

   // True if suspension time should be removed.
   optional bool remove_suspension_utc_time = 14;

   // What the client wants the order duration to become.
   // This field is associated with Order.Duration enum type.
   optional uint32 duration = 15;

   // What the client wants the order expiration date to become (see Order.good_thru_date).
   optional sint64 good_thru_date = 16;

   // What the client wants the order expiration time to become (see Order.good_thru_utc_time).
   // Note: use good_thru_utc_timestamp field instead.
   optional sint64 good_thru_utc_time = 17 [deprecated = true];

   // What the client wants the order expiration time to become (see Order.good_thru_utc_timestamp).
   // If specified by the user it's used instead of good_thru_utc_time field.
   optional google.protobuf.Timestamp good_thru_utc_timestamp = 21;

   // What the client wants the order discretionary_offset to become.
   optional uint32 discretionary_offset = 22;

   // List of order extra attributes, can be used to remove or modify existing or add new attributes.
   repeated shared_1.NamedValue extra_attribute = 26;

   // FIA Execution Source Code value of the operation.
   // See Order.execution_source_code
   optional string execution_source_code = 27;
}

// Cancel order request.
message CancelOrder
{
   // Order id assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // This client order ID of the order to cancel.
   required string orig_cl_order_id = 3;

   // Client order ID of this cancel request.
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 5 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 6;

   // List of order extra attributes, can be used to remove or modify existing or add new attributes.
   repeated shared_1.NamedValue extra_attribute = 7;
}

// Specifies an account and what orders to use in the account.
message AccountOrderFilter
{
   // ID of the order's account.
   required sint32 account_id = 1;

   // Specifies either all orders in the account or just orders in the
   // account associated with the trader sending the request.
   optional bool mine = 2 [default = true];

   // Specifies whether only suspended orders or all not suspended orders in the
   // account associated with the trader sending the request.
   optional bool suspended = 3 [default = false];

   // Specifies whether only BUY orders or only SELL orders.
   // This field is associated with Order.Side enum type.
   optional uint32 side = 4;

   // Use only orders of specified contract.
   optional uint32 contract_id = 5;

   // Specifies whether only order(s) expiring during the
   // current/nearest session should be considered.
   optional bool current_day_only = 6 [default = false];
}

// Cancel all orders request.
message CancelAllOrders
{
   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 1 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 4;

   // Client order ID of this cancel request.
   optional string cl_order_id = 2;

   // Specifies an account and what orders to cancel in the account.
   // All orders that meet the criteria (account, mine, suspended etc.) will be canceled.
   // At least one AccountOrderFilter should be present.
   repeated AccountOrderFilter account_order_filter = 3;
}

// Activate suspended (parked) order request.
message ActivateOrder
{
   // Order id assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // This client order ID of the order to activate.
   required string orig_cl_order_id = 3;

   // Client order ID of this activation request (will become new client order Id if activation is accepted).
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 5 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 6;

   // List of order extra attributes, can be used to remove or modify existing or add new attributes.
   repeated shared_1.NamedValue extra_attribute = 7;

   // FIA Execution Source Code value of the operation.
   // See Order.execution_source_code.
   optional string execution_source_code = 8;
}

// Modification of order's user attributes.
message ModifyUserAttributes
{
   // ID of the order chain.
   required string chain_order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // List of attributes to modify.
   // See Order.user_attribute for additional description.
   repeated UserAttribute user_attribute = 3;

   // Flag used by the client for marking the user attributes checked/unchecked.
   // Empty means to leave the flag the same as it was.
   optional bool is_checked = 4;
}

// Placement of a compound order.
message NewCompoundOrder
{
   // Compound order to place.
   required CompoundOrder compound_order = 1;

   // Indicates whether compound order execution shall happen on a partial fill (true or omitted)
   // or complete fill (false).
   optional bool partial_fills_handling = 2 [default = true];
}

// Compound order.
message CompoundOrder
{
   // Type of the compound order.
   enum Type
   {
      // Order Places Order.
      // [Partial] fill of the first entry triggers [partial] placement of all other orders.
      OPO = 1;

      // Order Cancels Order. This type allows several compound order entires.
      // [Partial] fill of any order triggers [partial] canceling of all other orders.
      OCO = 2;
   }
   // This field is associated with Type enum type.
   required uint32 type = 1;

   // ID of the compound order assigned by client.
   // Maximum allowed length is 64 bytes.
   required string cl_compound_id = 2;

   // List of entires.
   repeated CompoundOrderEntry compound_order_entry = 3;

   // Example of usage for next parameters:
   // User places a compound buy order at $50, tick size is equal to 1$, profit_tick_offset = 10,
   // loss_tick_offset = 5, and stop_limit_tick_offset = 15. When buy order is filled, OCO chain with 2 orders
   // is created: sell limit order at $60 and sell stop limit order at $45. If the price moves up to $60, the position
   // will be sold and stop sell order would be cancelled. If the prices moves down to $45, sell limit order is
   // cancelled and sell stop limit order becomes sell limit order at $30.

   // Offset in ticks from fill price (variable ticks size is supported). New order price will be
   // calculated as (fill price + offset) for buy master orders and (price - offset) for sell master orders.
   optional sint32 profit_tick_offset = 4;

   // Offset in ticks from fill price (variable ticks size is supported). New order price will be
   // calculated as (fill price - offset) for buy master orders and (price + offset) for sell master orders.
   optional sint32 loss_tick_offset = 5;

   // Offset in ticks from loss_tick_offset for stop limit orders (variable ticks size is supported).
   // The offset determines the limit price for stop limit order after the stop price is hit.
   optional sint32 stop_limit_tick_offset = 6;
}

// Use existing order.
message UseOrder
{
   // Order id of existing order assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;
}

// Entry of a compound order. Only one of optional fields has to be specified.
message CompoundOrderEntry
{
   // Regular order entry.
   optional Order order = 1;

   // Sub-compound order entry.
   optional CompoundOrder compound_order = 2;

   // Existing order entry.
   optional UseOrder use_order = 3;
}

// Suspend (park) order request.
message SuspendOrder
{
   // Order id assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // This client order ID of the order to suspend (park).
   required string orig_cl_order_id = 3;

   // Client order ID of this suspension request (will become new client order Id if suspension is accepted).
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 5 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 7;

   // Time when the suspended (parked) order should automatically activate (UTC).
   // Note: use activation_utc_timestamp field instead.
   optional sint64 activation_utc_time = 6 [deprecated = true];

   // Time when the suspended (parked) order should automatically activate (UTC).
   // If specified it's used instead of activation_utc_time field.
   // If neither this nor activation_utc_time field is specified, order must be activated by ActivateOrder request
   optional google.protobuf.Timestamp activation_utc_timestamp = 8;

   // List of order extra attributes, can be used to remove or modify existing or add new attributes.
   repeated shared_1.NamedValue extra_attribute = 9;
}

message Commission
{
   // Commission currency code (ISO 4217 based).
   required string commission_currency = 1;

   // Commission.
   required double commission = 2;
}

// Status of order.
message OrderStatus
{
   // List of trade subscription IDs this status is related to.
   repeated uint32 subscription_id = 1;

   // True if this is a snapshot related message.
   // Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
   // an indicator of complete snapshot delivery for a particular subscription.
   optional bool is_snapshot = 2;

   // This field is associated with shared_1.OrderStatus.Status enum type.
   required uint32 status = 3;

   // Order ID assigned by server.
   // It is changed by server after each modify request acknowledgment.
   required string order_id = 4;

   // Order ID assigned by server to originally placed order. It stays the same regardless of modification requests.
   required string chain_order_id = 5;

   // Order ID assigned by execution system (e.g. exchange).
   optional string exec_order_id = 6;

   // Last order change time from server perspective (UTC).
   // Note: use status_utc_timestamp field instead.
   optional sint64 status_utc_time = 7 [deprecated = true];

   // Last order change time from server perspective (UTC).
   required google.protobuf.Timestamp status_utc_timestamp = 24;

   // Time when original order was submitted to the execution system by server (UTC).
   // Note: use submission_utc_timestamp field instead.
   optional sint64 submission_utc_time = 8 [deprecated = true];

   // Time when original order was submitted to the execution system by server (UTC).
   required google.protobuf.Timestamp submission_utc_timestamp = 25;

   // Note: use fill_qty field instead.
   optional uint32 uint32_fill_qty = 9 [deprecated = true];

   // Filled quantity.
   optional cqg.Decimal fill_qty = 28;

   // Number of fill events.
   required uint32 fill_cnt = 10;

   // Average fill price.
   // NOTE: this price is aligned by ContractMetadata.correct_price_scale so don't use it for OTE/UPL calculation but
   // use prices from individual TRADE elements. See also avg_fill_price_correct field.
   required sint64 scaled_avg_fill_price = 11;

   // Average fill price in correct price format. Could have higher precision than avg_fill_price multiplied by correct_price_scale.
   required double avg_fill_price_correct = 27;

   // Time when order should be submitted to execution system as assigned by server (UTC).
   // Note: use active_at_utc_timestamp field instead.
   optional sint64 active_at_utc_time = 12 [deprecated = true];

   // Time when order should be submitted to execution system as assigned by server (UTC).
   optional google.protobuf.Timestamp active_at_utc_timestamp = 26;

   // Note: use remaining_qty field instead.
   optional uint32 uint32_remaining_qty = 13 [deprecated = true];

   // Remaining (unfilled) order quantity. It is not always equal
   // to order size minus filled size (for example, busted orders violate that).
   optional cqg.Decimal remaining_qty = 29;

   // Order with updated attributes. Server may not send it if order attributes remained the same since last update.
   optional Order order = 14;

   // List of [last] transactions. In case of initial snapshot (if last_orders_update_utc_time was not set in TradeSubscription)
   // all available transactions are sent. This list can be empty if this status is sent to update order attributes only
   // (e.g. to update prices of trailing orders).
   // It is guaranteed that this list is sorted by transaction indentifier (TransactionStatus.trans_id).
   repeated TransactionStatus transaction_status = 15;

   // Time of the latest REJECTED, REJECT_CANCEL or REJECT_MODIFY transaction, if any (UTC).
   optional google.protobuf.Timestamp reject_utc_timestamp = 30;

   // Message of the latest REJECTED, REJECT_CANCEL or REJECT_MODIFY transaction, if any.
   optional string reject_message = 31;

   // Time of the latest ACK_CANCEL transaction, if any (UTC).
   optional google.protobuf.Timestamp cancel_utc_timestamp = 32;

   // Time of the latest FILL or FILL_CORRECT transaction, if any (UTC).
   optional google.protobuf.Timestamp fill_utc_timestamp = 33;

   // Whether there is FILL_CORRECT with updated quantity. Canceled and busted fills are ignored.
   optional bool has_fill_with_modified_qty = 34;

   // Whether there is FILL_CORRECT with updated price. Canceled and busted fills are ignored.
   optional bool has_fill_with_modified_price = 35;

   // User who placed the order, or user on whose behalf the order was placed.
   required string entered_by_user = 16;

   // Statement date when this order was submitted.
   required sint64 first_statement_date = 17;

   // Last statement date this order belongs to. It is set when order is cleaned by a statement report or other event
   // so that order is not 'current' any longer. For example, canceled synthetic strategy leg orders without fills
   // may be cleared before the end of 'current' day.
   optional sint64 last_statement_date = 18;

   // Multiple OrderStatus and PositionStatus messages in a single ServerMsg can reference the same contract.
   // If the contract is unknown to the client before this ServerMsg, contract meta-data will be added in at least one of them.
   // If in your code you process orders first and positions second then during processing orders you may
   // encounter order with yet unknown contract_id.
   // In this case you should look for matching contract metadata in positions.
   // The opposite is also true: contract metadata for positions can be in order status messages.
   repeated ContractMetadata contract_metadata = 19;

   // Id of an account for this order status.
   required sint32 account_id = 20;

   // If the order is part of a compound order then this field describe the structure of the compound.
   optional CompoundOrderStructure compound_order_structure = 21;

   // The number of active (not resolved) hangs on this synthetic strategy order.
   optional uint32 hang_count = 22;

   // Synthetic order's outright properties
   optional SyntheticStrategyProperties strategy_properties = 23;
}

// Status of a specific transaction.
// All attributes are at the transaction moment.
message TransactionStatus
{
   // This field is associated with shared_1.TransactionStatus.Status enum type.
   required uint32 status = 1;

   // Order transaction identifier.
   // For all transactions within order chain it is guaranteed that:
   // 1) Transaction identifier is unique.
   // 2) The later transaction has greater transaction identifier than the earlier one.
   required uint64 trans_id = 2;

   // Transaction time assigned by server (UTC).
   // Note: use trans_utc_timestamp field instead.
   optional sint64 trans_utc_time = 3 [deprecated = true];

   // Transaction time assigned by server (UTC).
   required google.protobuf.Timestamp trans_utc_timestamp = 40;

   // Reference transaction ID to the previous fill transaction for a bust, cancel or correction.
   optional uint64 ref_trans_id = 4;

   // If order is modified, this client order ID of the order before modification.
   optional string orig_cl_order_id = 5;

   // Client order ID of the order at the transaction moment.
   required string cl_order_id = 6;

   // Note: use fill_qty field instead.
   optional uint32 uint32_fill_qty = 7 [deprecated = true];

   // Filled quantity for fill transactions or updated quantity for fill correction.
   optional cqg.Decimal fill_qty = 52;

   // Fill price for fill transactions or updated price for fill correction.
   optional sint64 scaled_fill_price = 8;

   // List of specific per leg trades (more than one for strategies).
   repeated Trade trade = 9;

   // List of leg order fills that contribute to a synthetic strategy order fill.
   // Present if the transaction is of type FILL or FILL_CORRECT and this order is a synthetic strategy order.
   // Mutually exclusive with 'trade' attribute.
   repeated StrategyLegFill strategy_leg_fills = 38;

   // Details of the hang
   optional SyntheticHang synthetic_hang = 39;

   // Note: use prev_order_qty field instead.
   optional uint32 uint32_prev_order_qty = 10 [deprecated = true];

   // If order is modified, this is the previous order size.
   optional cqg.Decimal prev_order_qty = 53;

   // Note: use order_qty field instead.
   optional uint32 uint32_order_qty = 11 [deprecated = true];

   // If order is modified, this is the updated order size.
   optional cqg.Decimal order_qty = 54;

   // If order is modified, this is the previous order limit price.
   optional sint64 scaled_prev_limit_price = 12;

   // If order is modified, this is the updated order limit price.
   optional sint64 scaled_limit_price = 13;

   // If order is modified, this is the previous order stop price.
   optional sint64 scaled_prev_stop_price = 14;

   // If order is modified, this is the updated order stop price.
   optional sint64 scaled_stop_price = 15;

   // Note: use prev_visible_qty field instead.
   optional uint32 uint32_prev_visible_qty = 16 [deprecated = true];

   // If order is modified, this is the previous visible order size.
   optional cqg.Decimal prev_visible_qty = 55;

   // Note: use visible_qty field instead.
   optional uint32 uint32_visible_qty = 17 [deprecated = true];

   // If order is modified, this is the updated visible order size.
   optional cqg.Decimal visible_qty = 56;

   // Note: use prev_min_visible_qty field instead.
   optional uint32 uint32_prev_min_visible_qty = 18 [deprecated = true];

   // If order is modified, this is the previous min visible order size.
   optional cqg.Decimal prev_min_visible_qty = 57;

   // Note: use min_visible_qty field instead.
   optional uint32 uint32_min_visible_qty = 19 [deprecated = true];

   // If order is modified, this is the updated min visible order size.
   optional cqg.Decimal min_visible_qty = 58;

   // Note: use prev_fill_qty field instead.
   optional uint32 uint32_prev_fill_qty = 20 [deprecated = true];

   // If fill is modified, the previous size is reported here.
   optional cqg.Decimal prev_fill_qty = 59;

   // If fill is modified, the previous price is reported here.
   optional sint64 scaled_prev_fill_price = 21;

   // If order is modified, this is the previous order type.
   // This field is associated with Order.OrderType enum type.
   optional uint32 prev_order_type = 22;

   // If order is modified, this is the updated order type.
   // This field is associated with Order.OrderType enum type.
   optional uint32 order_type = 23;

   // If order is modified, these are the previous exec instructions.
   // This field is associated with Order.ExecInstruction enum type.
   repeated uint32 prev_exec_instruction = 24;

   // If order is modified, these are the updated exec instructions.
   // This field is associated with Order.ExecInstruction enum type.
   repeated uint32 exec_instruction = 25;

   // If order is modified, this is the previous duration.
   // This field is associated with Order.Duration enum type.
   optional uint32 prev_duration = 26;

   // If order is modified, this is the new duration.
   // This field is associated with Order.Duration enum type.
   optional uint32 duration = 27;

   // If order is modified, this is the previous date then the order should expire  (see Order.good_thru_date).
   optional sint64 prev_good_thru_date = 28;

   // If order is modified, this is the updated date then the order should expire  (see Order.good_thru_date).
   optional sint64 good_thru_date = 29;

   // If order request is rejected, this is rejection code (the list is provided separately).
   optional uint32 reject_code = 30;

   // If present, identifies the counterpart of the order fill, as reported by the execution system.
   optional string fill_counterparty = 31;

   // Order identifier assigned by server when sending the order to execution system.
   optional string route_cl_order_id = 32;

   // Additional transaction details.
   optional string text_message = 33;

   // If order is modified, this is the previous time then the order should expire  (see Order.good_thru_utc_time).
   // Note: use prev_good_thru_utc_timestamp field instead.
   optional sint64 prev_good_thru_utc_time = 34 [deprecated = true];

   // If order is modified, this is the previous time then the order should expire  (see Order.good_thru_utc_timestamp).
   optional google.protobuf.Timestamp prev_good_thru_utc_timestamp = 41;

   // If order is modified, this is the updated time then the order should expire  (see Order.good_thru_utc).
   // Note: use good_thru_utc_timestamp field instead.
   optional sint64 good_thru_utc_time = 35 [deprecated = true];

   // If order is modified, this is the updated time then the order should expire  (see Order.good_thru_utc).
   optional google.protobuf.Timestamp good_thru_utc_timestamp = 42;

   // OrderRequest.client_regulatory_algorithm_id value echoed back from the latest order request.
   optional uint32 client_regulatory_algorithm_id = 36;

   // Regulatory Algorithm ID actually sent to the exchange for this order, if any.
   // Will differ from client_regulatory_algorithm_id if any CQG algorithm was applied to the order.
   optional uint32 effective_regulatory_algorithm_id = 37;

   // MiFID algorithm ID provided with this order request, contents depend on mifid_algorithm_id_type.
   optional string mifid_algorithm_id = 43;

   // Defines the type of mifid_algorithm_id reported. One of MiFIDAlgorithmIdType enum.
   optional uint32 mifid_algorithm_id_type = 44;

   // The MiFID algorithm ID associated with the order request for execution in this account.
   // It may have no relation to mifid_algorithm_id, e.g. in case client supplied a mifid_algorithm_id
   // and then a server-side algorithm was used, its identifier would be applied to the order instead.
   optional string mifid_applied_algorithm_id = 45;

   // The type of mifid_applied_algorithm_id reported. One of MiFIDAlgorithmIdType enum.
   optional uint32 mifid_applied_algorithm_id_type = 46;

   // Actual value of MiFID Execution Within Firm associated with this order for execution in this account,
   // reflects FCM + route short code mapping if configured.
   optional string mifid_execution_decision = 47;

   // Open/close effect of the order fill transaction as a result of the corresponding open_close_instruction.
   // One of OpenCloseInstruction enum.
   optional uint32 open_close_effect = 48;

   // Speculation type of the transaction. One of SpeculationType enum.
   optional uint32 speculation_type = 49;

   // If order is modified, this is the previous discretionary offset.
   optional uint32 prev_discretionary_offset = 50;

   // If order is modified, this is the updated discretionary offset.
   optional uint32 discretionary_offset = 51;

   // Commission charged for the fill.
   // CQG trade routing system might not provide this information for some contracts.
   optional Commission fill_commission = 60;

   // Decision Within Firm associated with this order.
   optional string mifid_investment_decision = 61;

   // Indicates whether MiFID investment decision identifies a person (false) or algorithm (true)
   optional bool mifid_investment_decision_is_algo = 62;

   // FIA Execution Source Code value of the operation.
   // See Order.execution_source_code
   optional string execution_source_code = 63;
}

// Trade per specific outright contract.
message Trade
{
   // Trade ID assigned by server, unique within account.
   required string trade_id = 1;

   // Server contract identifier.
   required uint32 contract_id = 2;

   // Brokerage statement date this trade corresponds to (in time format, convert to date only).
   required sint64 statement_date = 3;

   // Time of the trade (UTC).
   // Note: use trade_utc_timestamp field instead.
   optional sint64 trade_utc_time = 4 [deprecated = true];

   // Time of the trade (UTC).
   required google.protobuf.Timestamp trade_utc_timestamp = 12;

   // Exchange trade day this trade corresponds to (in time format, date only value).
   required sint64 trade_date = 5;

   // Trade price in native integer format.
   // price = round(price_correct / correct_price_scale).
   required sint64 scaled_price = 6;

   // Trade price in correct price format. Could have higher precision than price multiplied by correct_price_scale.
   required double price_correct = 13;

   // Trade side.
   // This field is associated with Order.Side enum type.
   required uint32 side = 7;

   // Note: use qty field instead.
   optional uint32 uint32_qty = 8 [deprecated = true];

   // Trade size.
   optional cqg.Decimal qty = 16;

   // If present, identifies the counter-party of the trade, as reported by the execution system
   // (may or may not match counter-party reported for the order fill).
   optional string trade_counterparty = 9;

   // Flag that trade was made as aggressive.
   optional bool is_aggressive = 10;

   // Execution id of the leg fill
   optional string leg_execution_id = 11;

   // Open/close effect of the trade as a result of the corresponding open_close_instruction.
   // One of OpenCloseInstruction enum.
   optional uint32 open_close_effect = 14;

   // Speculation type of the trade. One of SpeculationType enum.
   optional uint32 speculation_type = 15;
}

// Describes a leg order fill that contributes to a synthetic strategy order fill.
message StrategyLegFill
{
   // Order id for the leg order (the original OrderStatus.order_id)
   required string leg_order_id = 1;

   // Leg_execution_id of the corresponding Trade message for the leg order fill.
   required string leg_execution_id = 2;

   // Quantity of the leg order fill used for this synthetic strategy order fill,
   // decimal (fractional quantities are possible for legs with non-integer quantity ratio).
   // This is correct quantity (ContractMetadata.volume_scale must not be applied).
   required double qty = 3;
}

// Details of hung quantity on a synthetic strategy order or existing hang resolution
message SyntheticHang
{
   // Unique hang identifier supplied by server.
   required sint32 hang_id  = 1;

   // Note: use hung_qty field instead.
   optional uint32 uint32_hung_qty  = 2 [deprecated = true];

   // Quantity (of the synthetic strategy order) hung, 0 indicates that hang is resolved.
   optional cqg.Decimal hung_qty = 4;

   // Orders participating in a synthetic strategy order hang.
   // Note: this is the original OrderStatus.order_id.
   repeated string order_id = 3;
}

// Compound order structure.
message CompoundOrderStructure
{
   // This field is associated with CompoundOrder.Type enum type.
   // Type of the compound order.
   required uint32 type = 1;

   // ID of the compound order assigned by client.
   required string cl_compound_id = 2;

   // List of entires.
   repeated CompoundOrderStructureEntry compound_order_entry = 3;

   // Offset in ticks from fill price.
   // New order price will be calculated as (fill price + offset) for buy master orders and (fill price - offset) for sell master orders.
   optional sint32 profit_offset = 4;

   // Offset in ticks from fill price.
   // New order price will be calculated as (fill price - offset) for buy master orders and (fill price + offset) for sell master orders.
   optional sint32 loss_offset = 5;

   // Offset in ticks from loss_offset for stop limit orders.
   // The offset determines the limit price for the order the stop limit becomes when the stop price is hit.
   optional sint32 stop_limit_offset = 6;
}

// Entry of a compound order structure. One of optional fields is specified.
message CompoundOrderStructureEntry
{
   // Regular order id as assigned by server.
   optional string chain_order_id = 1;

   // Sub-compound order structure entry.
   optional CompoundOrderStructure compound_order_structure = 2;
}

// Parameters associated with a concrete leg.
message StrategyOrderLegParameters
{
   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index or LegDefinition.node_index value).
   required uint32 node_index = 1;

   // Account id to place an order on the leg. If not set, the account id of the order used instead.
   optional sint32 account_id = 2;

   // Specifies what the order is intended to do: open or close (reduce) a position. One of OpenCloseInstruction enum.
   // Applicable only if ContractMetadata.position_tracking is either LONG_SHORT_WITH_IMPLIED_CLOSE or LONG_SHORT_WITH_EXPLICIT_CLOSE.
   // If not set, the open/close instruction of the order used instead.
   optional uint32 open_close_instruction = 3;

   // Speculation type of the leg order. One of SpeculationType enum.
   // If not set, the speculation type of the order used instead.
   optional uint32 speculation_type = 4;
}

// Synthetic strategy MKT order parameters
message StrategyMarketOrderParameters
{
   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index).
   required uint32 node_index = 1;

   // For Iceberg orders:
   // 'true' means replenish qty on the filled leg immediately upon receiving primary fill;
   // 'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
   //         is filled or its qty changes for some other reason, e.g. replace request.
   optional bool replenish_on_primary_fill = 2;
}

// Parameters of LMT orders on a leg which is currently working.
message PrimaryOrdersLimit
{
   // Mode of working primary orders with price far from market.
   enum FarFromMarketMode
   {
      // Primary orders will be canceled (won't be placed) if a new target price is far from market.
      NO_ORDERS = 1;

      // Primary orders will be moved away from market (will be left untouched) if a new target price is far from market.
      MOVE_AWAY_ONLY = 2;

      // Primary orders will be left untouched if current and a new target price are both far from market.
      DONT_MOVE = 3;
   }

   // Modes of handling DOM data.
   enum DOMUsageMode
   {
      // Use only top levels of DOMs and produce a single level of primary orders.
      TOP_ONLY = 1;

      // Use multiple levels of DOMs and produce multiple levels of primary orders.
      MULTILEVELS = 2;

      // Produce a single level of primary orders of the full quantity corresponding to the worst DOM prices with a sufficient cumulative quantity.
      FULL_SIZE_WORST_PRICE = 3;

      // Produce a single level of primary orders of the full quantity corresponding
      // to average DOM prices with a sufficient cumulative quantity.
      FULL_SIZE_AVERAGE_PRICE = 4;
   }

   // Note: use min_qty_increment field instead.
   optional uint32 uint32_min_qty_increment = 1 [deprecated = true];

   // Place an order only if the quantity available in the monitored leg is at least this much and
   // to modify a working order only if the quantity available in the monitored leg increases by at least this much.
   // Default is 1.
   optional cqg.Decimal min_qty_increment = 18;

   // Queue holders (stacked orders) are additional orders placed in the queue at specified price levels away from the initial working order.
   // Sets the minimum number of orders to include in the queue.
   // Allowed values: 1-10, default is 1.
   optional uint32 queue_holders_min_size = 2;

   // Sets the maximum number of orders to include in the queue.
   // Allowed values: 1-10 and not less than queue_holders_min_size, default is 1.
   optional uint32 queue_holders_max_size = 3;

   // Indicates how many price levels (ticks) to skip between orders in the queue.
   // Allowed range is 1-5, default is 1.
   optional uint32 queue_holders_distance = 4;

   // Indicates how far the market should run before maximizing size of a recently placed order that is now part of the group of stacked orders.
   // Must be less than queue_holders_min_size, default is 0.
   optional uint32 order_size_restore_threshold = 5;

   // Note: use visible_qty field instead.
   optional uint32 uint32_visible_qty = 6 [deprecated = true];

   // Primary Iceberg order visible size in lots.
   optional cqg.Decimal visible_qty = 19;

   // Note: use min_visible_qty field instead.
   optional uint32 uint32_min_visible_qty = 7 [deprecated = true];

   // Primary Iceberg order min visible size in lots.
   optional cqg.Decimal min_visible_qty = 20;

   // Maximal distance between the market price and the old/new limit price of working primary leg
   // orders, which allows modifications of these orders' prices(in ticks).
   // Zero value is acceptable and means that the orders are modified at any distance.
   // 0 is default.
   optional uint32 working_orders_price_range = 8;

   // Minimal difference between the old and the new limit prices of working
   // primary leg orders, which allows modifications of these orders' prices (in ticks).
   optional uint32 min_price_change = 9;

   // Maximum number of leg orders per price level
   optional uint32 primary_orders_fifo_queue_size = 10;

   // Period of updates to the working leg in milliseconds, such that every N ms,
   // the leg is put where it ought to be placed based upon current prices.
   // Default is to use the server settings.
   optional uint32 force_update_period = 11;

   // Flag that shows whether observed markets must be used for primary orders size calculation or not.
   optional bool ignore_observed_markets = 12;

   // Specifies (in ticks) maximum distance primary order price could be moved from target one while creating best bid/ask.
   optional uint32 max_dimming = 13;

   // Mode of handling primary leg orders with target price far from market. One of FarFromMarketMode enums.
   // Default is to use the server settings.
   optional uint32 far_from_market_mode = 14;

   // Defines if and where server must work quantity that cannot lean onto current best bid/offer.
   // Allowed range 0-9, default is to use the server setting.
   optional int32 ticks_away_to_work = 15;

   // How to work orders considering DOM data. One of DOMUsageMode enums. TOP_ONLY is default.
   optional uint32 dom_usage = 16;

   // Work up to this number of orders to get required volume if dom_usage is MULTILEVELS.
   // Allowed range 1-10, default is 1.
   optional uint32 dom_multilevel_qty = 17;
}

// Sniper rule means don't place any primary order.
// It just watches markets waiting for the moment when the strategy order's LMT price is available.
// Then secondary orders on all legs must be placed.
message PrimaryOrdersSniper
{
   // Duration for sniper leg orders
   enum LegDuration
   {
      DAY = 1;

      // Fill and kill
      FAK = 2;

      // Fill or kill
      FOK = 3;
   }

   // One of LegDuration enums.
   required uint32 leg_duration = 1;
}

// LMT secondary orders parameters.
message SecondaryOrdersLimit
{
   // Offset to adjust secondary order price at the moment of place. Default is 0.
   optional double initial_offset = 1;
}

// MKT secondary orders parameters.
message SecondaryOrdersMarket
{
}

// Pay up secondary orders parameters.
message SecondaryOrdersPayUp
{
   // Offset to modify the price of a hung secondary order.
   required double offset = 1;

   // Offset to adjust the secondary order price at the moment of placement.
   optional double initial_offset = 2;

   // One of the conditions below must be set.
   // Condition to check that pointed time interval is passed.
   optional uint32 condition_timeout = 3;

   // Note: use condition_absolute_volume field instead.
   optional uint32 uint32_condition_absolute_volume = 4 [deprecated = true];

   // Condition to check the opposite market volume.
   optional cqg.Decimal condition_absolute_volume = 7;

   // Condition to check the ratio between the opposite side and secondary order sizes.
   optional double condition_opposite_volume_ratio = 5;

   // Condition to check the opposite side and the local side volumes ratio.
   optional double condition_bba_volume_ratio = 6;
}

// Trailing secondary orders parameters.
message SecondaryOrdersTrailing
{
   // Trailing offset.
   required double trailing_offset = 1;

   // Peg that price must follow. One of Order.TrailingPeg enum.
   required uint32 trailing_peg = 2;

   // Offset to adjust secondary order price at the moment of place.
   optional double initial_offset = 3;

   // Maximum distance to trail away from the initial price.
   optional double max_trail = 4;

   // One of the conditions below must be set.

   // Note: use condition_absolute_volume field instead.
   optional uint32 uint32_condition_absolute_volume = 5 [deprecated = true];

   // Condition that checks the opposite market volume.
   optional cqg.Decimal condition_absolute_volume = 8;

   // Condition that checks relation between opposite side and secondary order sizes.
   optional double condition_opposite_volume_ratio = 6;

   // Condition that checks the opposite side and the local side volumes ratio
   optional double condition_bba_volume_ratio = 7;
}

// LMT order parameters for a leg.
message LimitOrderLegDescription
{
   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index or LegDefinition.node_index value).
   required uint32 node_index = 1;

   // All the attributes below are mutually exclusive.
   // Sets the leg as working and place LMT orders.
   optional PrimaryOrdersLimit primary_order_limit = 2;

   // Sets the leg as working and place sniper orders.
   optional PrimaryOrdersSniper primary_order_sniper = 3;

   // Sets the leg as not working and place LMT orders.
   optional SecondaryOrdersLimit secondary_orders_limit = 4;

   // Sets the leg as not working and place MKT orders.
   optional SecondaryOrdersMarket secondary_orders_market = 5;

   // Sets the leg as not working and place payup orders.
   optional SecondaryOrdersPayUp secondary_orders_payup = 6;

   // Sets the leg as not working and place trailing orders.
   optional SecondaryOrdersTrailing secondary_orders_trailing = 7;

   // Indicates how many lots (in fractions) should be filled before the second leg order is placed.
   // Allowed range 0-1.
   // Default is off, the secondary leg placed after all lots are filled on the primary leg.
   optional double proportional_execution_ratio = 8;

   // Determines the size of working orders based on a percentage of the resting volume available in the queue of the monitored leg.
   // Allowed range 0-1000.
   // Default is 1.
   optional double volume_multiplier = 9;

   // Note: use work_threshold field instead.
   optional uint32 uint32_work_threshold = 10 [deprecated = true];

   // Tells the system to work the order if and only if the available quantity in the monitored leg is and remains greater than this value.
   // Default is 0.
   optional cqg.Decimal work_threshold = 11;
}

// Parameters for strategy price change depending on filled strategy size.
message PriceShifting
{
   // step (in ticks) of each price change.
   required int32 price_step = 1;

   // Note: use filled_qty_delta instead.
   optional uint32 uint32_filled_qty_delta = 2 [deprecated = true];

   // Size of strategy order that must be filled to perform next change of strategy order price.
   optional cqg.Decimal filled_qty_delta = 3;
}

// LMT order parameters of the root or a nested strategy.
message StrategyLimitOrderParameters
{
   // Mode of overfill handling
   enum OverfillMode
   {
      // Overfills are allowed and managed by trader
      MANUAL = 1;

      // Overfills are allowed and must be hedged by the server according to strategy quantity ratios
      AUTOMATIC_HEDGING = 2;

      // Minimize probability of overfills
      AVOID_OVERFILLS = 3;
   }

   // Defines sizes of what leg orders must be aligned to strategy lots (opposite to work proportionally).
   enum AlignToStrategyLots
   {
      // Both primary and secondary leg orders could work its sizes proportionally (without aligning it to strategy lot)
      NONE = 1;

      // Secondary leg orders must align its size to strategy lots
      SECONDARY_ONLY = 2;

      // Both primary and secondary leg orders align its sizes to strategy lots
      ALL = 3;
   }

   // The way prices for secondary orders are calculated
   enum PricingMethod
   {
      // Respect each strategy lot price independently
      INDEPENDENT_LOT_PRICE = 1;

      // Respect average strategy order price
      AVERAGE_ORDER_PRICE = 2;
   }

   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index value).
   required uint32 node_index = 1;

   // Defines whether replenish quantity on primary fill or not.
   // For Iceberg orders:
   //  'true' means replenish quantity on the filled leg immediately upon receiving primary fill;
   //  'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
   //          is filled or its quantity changes for some other reason, e.g. replace request.
   optional bool replenish_on_primary_fill = 2;

   // Defines mode of overfill handling for this limit SS order. One of OverfillMode enums.
   // AUTOMATIC_HEDGING is default.
   optional uint32 overfill_mode = 3;

   // Defines sizes of what leg orders must be aligned to strategy lots.One of AlignToStrategyLots enums.
   // NONE is default.
   optional uint32 align_to_strategy_lots = 4;

   // The way prices for secondary leg orders are calculated. One of PricingMethod enums.
   // AVERAGE_ORDER_PRICE is default
   optional uint32 pricing_method = 5;

   // Price shifting parameters.
   optional PriceShifting price_shifting = 6;

   // Parameters for strategy legs.
   repeated LimitOrderLegDescription leg_description = 7;
}

// STP order parameters of the root or a nested strategy.
message StrategyStopOrderParameters
{
   // Enumeration of sides of strategy price that STP orders watch for.
   enum StopSide
   {
      // Bid price of strategy must be matched against STP price.
      BID = 1;

      // Ask price of strategy must be matched against STP price.
      ASK = 2;
   }

   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index value).
   required uint32 node_index = 1;

   // The side of strategy price that STP orders watch for. One of StopSide enums.
   required uint32 stop_side = 2;

   // For Iceberg orders:
   //  'true' means replenish qty on the filled leg immediately upon receiving primary fill;
   //  'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
   //          is filled or its qty changes for some other reason, e.g. replace request.
   optional bool replenish_on_primary_fill = 3;
}

// Aggregation market taking mode: the order is held on the server until the price becomes available in at least one market;
// at which time, the server sends an order to the exchange.
message MarketTakingParameters
{
   // Type of order placed for the leg.
   enum MarketTakingLimitOrderType
   {
      LMT = 1;

      MKT = 2;
   }

   // Allocation percent (in range 0...1) for the leg (must total 100% among all legs).
   required double allocation_percent = 1;

   // Time period (in ms) that the order can work (after exchange ack)
   // before the server considers it timed out and cancels it (0 means 'never',
   // leaves order working until filled, cancelled, or expired).
   required uint32 working_timeout = 2;

   // Type of order placed for the leg. One of MarketTakingLimitOrderType enums.
   required uint32 order_type = 3;
}

// Aggregation market making mode: the order is sent immediately to the exchanges based on the allocation percent.
// The server then manages the orders to get them filled as quickly as possible at the given price.
message MarketMakingParameters
{
   // Allocation percent (in range 0...1) for the leg (doesn't have to total 100% allocation among all legs).
   // Default is 0, the market making mode is turned off for the leg.
   optional double allocation_percent = 1;

   // Note: use visible_qty instead.
   optional uint32 uint32_visible_qty = 2 [deprecated = true];

   // Note: use min_visible_qty instead.
   optional uint32 uint32_min_visible_qty = 3 [deprecated = true];

   // Note: use native_visible_qty instead.
   optional uint32 uint32_native_visible_qty = 4 [deprecated = true];

   // Visible size in lots.
   optional cqg.Decimal visible_qty = 5;

   // Min visible size in lots.
   optional cqg.Decimal min_visible_qty = 6;

   // Visible size of native Iceberg.
   optional cqg.Decimal native_visible_qty = 7;
}

// Description of aggregation strategy legs.
message AggregationLegDescription
{
   // Node index in the strategy definition the parameters are related to (LegDefinition.node_index value).
   required uint32 node_index = 1;

   // Note: use working_threshold instead.
   optional uint32 uint32_working_threshold = 2 [deprecated = true];

   // Threshold value for available quotes quantity to be considered
   // (the quantities under this value are ignored).
   optional cqg.Decimal working_threshold = 5;

   // The leg is executed in market taking mode.
   required MarketTakingParameters market_taking_parameters = 3;

   // The leg is executed in market making mode.
   required MarketMakingParameters market_making_parameters = 4;
}

message StrategyAggregationParameters
{
   // Mode of overfill handling.
   enum AggrOverfillMode
   {
      // Minimize probability of overfills: don't place market taking LMT until existing market making LMT on other legs have quantity reduction acknowledge.
      AVOID_OVERFILLS = 1;

      // Place market taking LMTs and then attempt to reduce market making LMT quantity on other legs.
      // There is a window of time where leg orders may be working that total more than the strategy order quantity.
      ACCEPT_OVERFILL = 2;

      // Place market taking LMT and wait to reduce market making LMT qty on other legs until
      // the market taking LMT are filled (or cancelled after timeout).
      // There is a much larger window of time where leg orders
      // may be working that total more than the strategy order qty,
      // but market making LMT don't lose their place in queue.
      PRESERVE_QUEUE_POSITION = 3;
   }

   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index).
   required uint32 node_index = 1;

   // Mode of overfill handling. One of AggrOverfillMode enums
   required uint32 overfill_mode = 2;

   // Price shifting parameters.
   optional PriceShifting price_shifting = 3;

   // Aggregation legs parameters.
   repeated AggregationLegDescription pattern_legs = 4;
}

// Defines how a placed synthetic strategy order will be executed.
message StrategyTradingParameters
{
   // Parameters applied only to a MKT order.
   repeated StrategyMarketOrderParameters market_order_parameters = 1;

   // Parameters applied only to a LMT order.
   repeated StrategyLimitOrderParameters limit_order_parameters = 2;

   // Parameters applied only to a STP order.
   repeated StrategyStopOrderParameters stop_order_parameters = 3;

   // Parameters applied only to an aggregation strategy.
   repeated StrategyAggregationParameters aggregation_parameters = 4;

   // Individual strategy leg parameters.
   repeated StrategyOrderLegParameters leg_parameters = 5;
}

// Status of a contract open positions and purchase and sales for a specific account for the current day
// (contractId and accountId are used as a key for updates).
// Contract position is deleted when all open positions and purchase and sales groups are deleted.
message PositionStatus
{
   // List of trade subscription IDs this status is related to.
   repeated uint32 subscription_id = 1;

   // True if this is a snapshot related message.
   // Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
   // an indicator of complete snapshot delivery.
   optional bool is_snapshot = 2;

   // Account this position belongs to.
   required sint32 account_id = 3;

   // Contract ID assigned by server.
   required uint32 contract_id = 4;

   // True if open positions are short (result of sell operations), long otherwise.
   // In case of separated long and short positions the value is true if the cumulative position is short,
   // the value is false if the cumulative position is long or flat.
   // The attribute is deprecated, refer to OpenPosition.is_short instead.
   required bool is_short_open_position = 5 [deprecated = true];

   // List of new/ updated or deleted open positions.
   // NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
   repeated OpenPosition open_position = 6;

   // List of purchase and sales groups. This group represent offset trades (usually one sell and one buy)
   // NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
   repeated PurchaseAndSalesGroup purchase_and_sales_group = 7;

   // Multiple OrderStatus and PositionStatus messages in a single ServerMsg can reference the same contract.
   // If the contract is unknown to the client before this ServerMsg, contract meta-data will be added in at least one of them.
   // If in your code you process orders first and positions second then during processing orders you may
   // encounter order with yet unknown contract_id.
   // In this case you should look for matching contract metadata in positions.
   // The opposite is also true: contract metadata for positions can be in order status messages.
   optional ContractMetadata contract_metadata = 8;

   // Sum of today fill commissions per currency for the contract.
   // Aggregated value from TransactionStatus.fill_commission for current day orders.
   repeated Commission today_fill_commission = 9;
}

// Account and contract open position.
// There could be more than one position per account and contract.
// (id is used as a key for updates).
message OpenPosition
{
   // Surrogate id as a key for updates.
   required sint32 id = 1;

   // Note: use qty field instead.
   optional uint32 uint32_qty = 2 [deprecated = true];

   // Position size, zero means that this position is deleted.
   // Note: quantity can be safely compared to zero, because this is an integral number of
   // ContractMetadata.volume_scale units.
   optional cqg.Decimal qty = 12;

   // Position average price.
   // NOTE: Since it could be an aggregated position price is sent in correct format directly.
   required double price_correct = 3;

   // Exchange specific trade date when the position was open or last changed (date only value).
   required sint64 trade_date = 4;

   // Statement date (date value only).
   required sint64 statement_date = 5;

   // UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
   // Note: use trade_utc_timestamp field instead.
   optional sint64 trade_utc_time = 6 [deprecated = true];

   // UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
   optional google.protobuf.Timestamp trade_utc_timestamp = 8;

   // True if the price is an aggregated position price.
   required bool is_aggregated = 7;

   // True if the open position is short (result of a sell operation), long otherwise.
   // Undefined for deleted position (qty is 0).
   required bool is_short = 9;

   // Whether it is a yesterday or a today position.
   // NOTE: where available, this attribute is from the exchange trade date perspective. It is used for
   // position tracking and open/close instructions. It is not the same as previous day (associated
   // with brokerage statement) vs. intraday. It is also not static. For example, an intraday fill
   // with open_close_effect=OPEN will appear, when it is received during the trading session, in an open
   // position or matched trade with is_yesterday=false. After the exchange trade date rolls over for
   // that contract, and before the brokerage statement arrives reflecting it as a previous day position,
   // the same open position or matched trade will contain is_yesterday=true.
   optional bool is_yesterday = 10 [default = false];

   // Speculation type of the position. One of SpeculationType enum.
   optional uint32 speculation_type = 11;
}

// Purchase and sales group that represents offset trades (usually one sell and one buy trade)
message PurchaseAndSalesGroup
{
   // Surrogate id as a key for updates.
   required sint32 id = 1;

   // Profit/ loss (in contract currency) of the group.
   required double realized_profit_loss = 2;

   // list of matched trades in a group
   // in case of group updates the whole list is sent
   repeated MatchedTrade matched_trade = 3;
}


// Specific trade or position that is a part of a purchase and sales group.
// (id is used as a key for updates).
message MatchedTrade
{
   // Note: use qty field instead.
   optional uint32 uint32_qty = 1 [deprecated = true];

   // Matched size.
   // Zero means matched trade is deleted.
   // Note: quantity can be safely compared to zero, because this is an integral number of
   // ContractMetadata.volume_scale units.
   optional cqg.Decimal qty = 12;

   // True if this is a short trade (e.g. result of sell operation), long otherwise.
   optional bool is_short = 2;

   // Trade or position average price.
   // NOTE: Since it could be an aggregated position price is sent in correct format directly.
   required double price = 3;

   // Trade date (date value only).
   required sint64 trade_date = 4;

   // Statement date (date value only).
   required sint64 statement_date = 5;

   // UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
   // Note: use trade_utc_timestamp field instead.
   optional sint64 trade_utc_time = 6 [deprecated = true];

   // UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
   optional google.protobuf.Timestamp trade_utc_timestamp = 8;

   // True if the price is an aggregated position price.
   required bool is_aggregated = 7;

   // Whether the trade is of a yesterday or a today position.
   // NOTE: where available, this attribute is from the exchange trade date perspective. It is used for
   // position tracking and open/close instructions. It is not the same as previous day (associated
   // with brokerage statement) vs. intraday. It is also not static. For example, an intraday fill
   // with open_close_effect=OPEN will appear, when it is received during the trading session, in an open
   // position or matched trade with is_yesterday=false. After the exchange trade date rolls over for
   // that contract, and before the brokerage statement arrives reflecting it as a previous day position,
   // the same open position or matched trade will contain is_yesterday=true.
   optional bool is_yesterday = 9 [default = false];

   // Whether the trade closed a new position or opened a new one.
   // Applicable only if ContractMetadata.position_tracking is not NET_POSITION.
   optional bool is_close = 10;

   // Speculation type of the trade. One of SpeculationType enum.
   optional uint32 speculation_type = 11;
}

// Status of the collateral for a specific account.
// An update is sent once it is changed, updates might be consolidated in case of frequent changes.
message CollateralStatus
{
   // List of trade subscription IDs this status is related to.
   repeated uint32 subscription_id = 1;

   // True if this is a snapshot related message.
   // Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
   // an indicator of complete snapshot delivery for a particular subscription.
   optional bool is_snapshot = 2;

   // Account id of this status.
   required sint32 account_id = 3;

   // Currency code of margin and PP values (ISO 4217 based).
   required string currency = 4;

   // Margin requirement calculated for worst-case based on open positions and working orders.
   required double total_margin = 5;

   // Margin requirement based on current positions only.
   optional double position_margin = 11;

   // Available account funds including balance, realized profit (or loss), collateral and credits.
   // OTE and MVO are included regarding the account risk parameters.
   required double purchasing_power = 6;

   // Open trade equity, or potential profit (or loss) from futures and future-style options positions
   // based on opening price of the position and the current future trade/best bid/best ask
   // (regarding to the risk account settings) or settlement price if trade is not available.
   // Included if purchasing power depends on it.
   optional double ote = 7;

   // Market value of options calculated as the current market trade/best bid/best ask of the option
   // (regarding to the risk account settings) times the number of options
   // (positive for long options and negative for short options) in the portfolio.
   // Included if purchasing power depends on it.
   optional double mvo = 8;

   // Market value of futures calculated as the current market trade/best bid/best ask
   // (regarding to the risk account settings) times the number of futures
   // (positive for long and negative for short) in the portfolio.
   // Included if applicable.
   optional double mvf = 10;

   // Allowable margin credit of the account
   optional double margin_credit = 9;
}

// Request to resolve previously reported hung quantity on a synthetic strategy order by
// 1) placing orders to offset filled leg position(s) at current mkt price(s) and (simultaneously)
// 2) cancelling the hung quantity.
message SyntheticLiquidate
{
   // Id of an account that is used to place an order.
   required sint32 account_id = 1;

   // Order id assigned by server after last modification.
   required string order_id = 2;

   // Id of the hang from the SyntheticHang message.
   required sint32 hang_id = 3;

   // Client side time when a request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 4 [deprecated = true];

   // Client side time when a request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 5;
}

// Request to resolve previously reported hung quantity on a synthetic strategy order by
// 1) placing LMT orders to offset filled leg position(s) at their fill price(s) and (simultaneously)
// 2) cancelling the hung quantity.
message SyntheticScratch
{
   // Id of an account that is used to place an order.
   required sint32 account_id = 1;

   // Order id assigned by server after last modification.
   required string order_id = 2;

   // Id of the hang from the SyntheticHang message.
   required sint32 hang_id = 3;

   // Client side time when a request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 4 [deprecated = true];

   // Client side time when a request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 5;
}

// Modify an order to get an immediate fill
// (on either the entire order or previously reported hanging quantity on a synthetic strategy order).
message GoMarket
{
   // Id of an account that is used to place an order.
   required sint32 account_id = 1;

   // Order id assigned by the server after the last modification.
   required string order_id = 2;

   // Id of the hang from the SyntheticHang message, if this request applies to hung quantity on a synthetic strategy order;
   // Not set, if this request applies to the whole order.
   optional sint32 hang_id = 3;

   // Client side time when a request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 4 [deprecated = true];

   // Client side time when a request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 5;
}

// Specify account and its positions.
message AccountPositionFilter
{
   // Id of an account.
   required sint32 account_id = 1;

   // Server side contract id.
   optional uint32 contract_id = 2;

   // Specifies whether only short (true) or only long (false) positions should be selected.
   // If not specified, both short and long positions will be selected.
   optional bool is_short = 3;

   // Specifies whether only positions of current day (true)
   // or only positions of previous days (false) should be selected.
   // If not specified, positions of current and previous day(s) will be selected.
   // Should be used only if instrument supports explicit close for positions.
   // If specified, and any instrument not supporting explicit close matches this filter,
   // ServerMsg.OrderRequestReject is sent.
   optional bool current_day_only = 4;
}

// Liquidate all open positions.
message LiquidateAll
{
   // Accounts and positions to liquidate.
   // At least one AccountPositionFilter should be specified, otherwise ServerMsg.OrderRequestReject is sent.
   // Position matching any filter is to be liquidated.
   repeated AccountPositionFilter account_position_filter = 1;

   // Client side time when this request was submitted (UTC).
   required google.protobuf.Timestamp when_utc_timestamp = 2;

   // FIA Execution Source Code value of the operation.
   // See Order.execution_source_code.
   optional string execution_source_code = 3;
}

// Cancel all orders (including parked) and liquidate all open positions.
message GoFlat
{
   // Id of an account. At least one should be specified, otherwise ServerMsg.OrderRequestReject is sent.
   repeated sint32 account_id = 1;

   // Client side time when this request was submitted (UTC).
   required google.protobuf.Timestamp when_utc_timestamp = 2;

   // FIA Execution Source Code value of the operation.
   // See Order.execution_source_code.
   optional string execution_source_code = 3;
}

////------------------------------------------
//// Market Data messaging

// Subscription to market data.
// If it is necessary to change subscription level client should send a new subscription request with the same ID
// but a new subscription level.
message MarketDataSubscription
{
   // Level or subscription.
   enum Level
   {
      // Unsubscribe.
      NONE = 0;

      // Get only settlement quotes.
      // NOTE: MarketValues will contain only settlements
      SETTLEMENTS = 5;

      // Get only market values.
      // NOTE: Array of quotes in RealTimeMarketData message will be always empty.
      MARKET_VALUES = 6;

      // Get trade and settlement quotes.
      TRADES = 1;

      // Get trades, settlement and best ask & bid without volumes.
      TRADES_BBA = 2;

      // Get trades, settlement and best ask & bid with volumes.
      TRADES_BBA_VOLUMES = 3;

      // All price data including DOM.
      TRADES_BBA_DOM = 4;
   }

   // Contract ID to subscribe (see symbol resolution report).
   // This is client's responsibility to re-subscribe in case of symbol resolution update.
   required uint32 contract_id = 1;

   // Subscription level.
   // This field is associated with Level enum type.
   // Note: level can be decreased if the client is prohibited to get requested data.
   // Result level will be available in MarketDataSubscriptionStatus.
   required uint32 level = 2;

   // Defines market values array in real-time market data snapshot.
   // False or omitted means that snapshots will contain market values for current trading day only (if available)
   // True means that snapshots may contain market values for several (up to 3) past trading days.
   optional bool include_past_market_values = 3;

   // Reserved field number (do not reuse).
   optional sint64 reserved1 = 4;

   // Defines quotes array in real-time market data snapshot.
   // False or omitted means that snapshots will contain last known ask, bid, trade and settlement for current trading day.
   // True means that snapshots will contain last known ask, bid, trade and settlement for last N trading days.
   // Note: N by default equals to 7 and can't be changed by client. Contact customer support if you want to increase this value.
   optional bool include_past_quotes = 5;

   // Whether need to include discretionary quotes in real-time market data.
   // Note: Flag is ignored (considered as False) if the client is prohibited to get discretionary quotes.
   // Result value will be available in MarketDataSubscriptionStatus.
   optional bool include_discretionary_quotes = 6;

   // Defines session market values array in real-time market data snapshot.
   // False or omitted means that snapshots will not contain session market values
   // True means that snapshots may contain session market values for several sessions.
   optional bool include_session_market_values = 9;

   // Specifies that quotes and market values need to include yields.
   // Result value will be available in MarketDataSubscriptionStatus.
   optional bool include_yields = 8;

   // Optional contributor ID for contributor specific data subscriptions.
   optional string contributor_id = 7;
}

// Subscription status
message MarketDataSubscriptionStatus
{
   enum StatusCode
   {
      /// success codes (0 - 99)
      SUCCESS = 0;

      // Currently subscription is disconnected. Possible reasons: communication issues, metadata update.
      // NOTE: Clients should not resubscribe in this case, the server will restore subscription with
      // sending SUCCESS status.
      DISCONNECTED = 1;

      /// failure codes (100+)
      // general failure
      FAILURE = 101;

      // Subscription parameters are invalid.
      INVALID_PARAMS = 102;

      // The user is not allowed to be subscribed to this Instrument.
      ACCESS_DENIED = 103;

      // Market data source was deleted because of expiration or by another reason.
      DELETED = 104;

      // The subscription count limit has been violated.
      SUBSCRIPTION_LIMIT_VIOLATION = 105;

      // Contributor ID is required for this subscription but was not provided or not authorized.
      CONTRIBUTOR_REQUIRED = 106;

      // The subscription rate limit has been violated.
      SUBSCRIPTION_RATE_LIMIT_VIOLATION = 107;

      // Market data subscription is not supported for specified contract.
      NOT_SUPPORTED = 110;
   }

   // Subscription contract ID.
   required uint32 contract_id = 1;

   // Subscription result.
   // This field is associated with StatusCode enum type.
   required uint32 status_code = 2;

   // Effective subscription level.
   // This field is associated with MarketDataSubscription.Level enum type.
   required uint32 level = 3;

   // Possible details of subscription failure.
   optional string text_message = 4;

   // Reserved field number (do not reuse).
   optional sint64 reserved1 = 5;

   // Specifies whether past quotes are included into real-time market data snapshot or not.
   // Always False if user didn't request past quotes.
   optional bool past_quotes_included = 6;

   // Specifies whether discretionary quotes are included into real-time market data or not.
   // Always False if user didn't request discretionary quotes.
   optional bool discretionary_quotes_included = 7;

   // Specifies whether intraday session market values are included into real-time market data or not.
   optional bool session_market_values_included = 10;

   // Specifies whether yields are included into real-time market data or not.
   optional bool yields_included = 9;

   // Contributor ID for contributor specific data subscriptions.
   optional string contributor_id = 8;
}

// Real time data delivery.
// Snapshot is sent as the first message after subscription and may appear periodically when subscribed.
message RealTimeMarketData
{
   // Contract ID assigned by server.
   required uint32 contract_id = 1;

   // Contract quotes. DOM is updated by new volumes per price. Zero volume is used to clean this price record from DOM.
   // Snapshot quotes have no indicators.
   repeated Quote quote = 2;

   // True if this is a snapshot (all previously known quotes about this contract should be cleaned).
   optional bool is_snapshot = 3;

   // Collapsing level that was applied by server.
   // NONE if the field is omitted.
   // This field is associated with RealTimeCollapsing.Level enum type.
   optional uint32 collapsing_level = 4;

   // Market values of a contract (e.g. Open/High/Low/Close) for several past trading days.
   // Present in snapshots and in updates if some values are changed (only changed values are included in updates).
   repeated MarketValues market_values = 5;
}

// Specific quote information
message Quote
{
   // Type of the quote.
   enum Type
   {
      // Trade quote.
      TRADE = 0;

      // Best bid quote.
      // Note that best bid/ask quotes are not guaranteed to be consistent with bid/ask quotes in the short
      // term. Thus, best bid/ask quotes must not be used to update DOM.
      BESTBID = 1;

      // Best ask quote.
      // See the note for BESTBID.
      BESTASK = 2;

      // Bid quote (DOM level).
      BID = 3;

      // Ask quote (DOM level).
      ASK = 4;

      // Settlement quote.
      SETTLEMENT = 5;

      // Best discretionary bid quote.
      // See the note for BESTBID.
      // Note: volume from discretionary quote is also included in a corresponding regular quote,
      // but there is no guarantee they are consistent in the short term.
      BESTDISCRBID = 6;

      // Best discretionary ask quote.
      // See the note for BESTDISCRBID.
      BESTDISCRASK = 7;

      // Discretionary bid quote (DOM level).
      // See the note for BESTDISCRBID.
      DISCRBID = 8;

      // Discretionary ask quote (DOM level).
      // See the note for BESTDISCRBID.
      DISCRASK = 9;
   }
   // This field is associated with Type enum type.
   required uint32 type = 1;

   // Time of the quote (UTC).
   // It is set only if time of this quote is different from the previous one in the list of quotes.
   optional sint64 quote_utc_time = 2;

   // Quote price.
   required sint32 scaled_price = 3;

   // Yield
   // Included if subscribed and the contract support yields.
   optional double price_yield = 6;

   // Quote volume (included for BBA only if volume is subscribed).
   // Zero volume for a bid or ask indicates it has been cleared.  It can be a best price and a part of DOM update.
   optional uint64 scaled_volume = 4;

   // Optional indicator(s) (e.g. this quote also updates some of Open/High/Low/Close session prices).
   enum Indicator
   {
      // Price of this quote is a new open price of the contract session.
      OPEN = 1;

      // Price of this quote is a new high price of the contract session.
      HIGH = 2;

      // Price of this quote is a new low price of the contract session.
      LOW = 3;

      // Price of this quote is a new close price of the contract session.
      CLOSE = 4;

      // This quote doesn't belong to current trading day.
      PAST = 5;
   }
   // This field is associated with Indicator enum type.
   repeated uint32 indicator = 5;
}

// Market data values of a contract.
message MarketValues
{
   // Open price.
   optional sint32 scaled_open_price = 1;

   // High price.
   optional sint32 scaled_high_price = 2;

   // Low price.
   optional sint32 scaled_low_price = 3;

   // Close price.
   optional sint32 scaled_close_price = 4;

   // Yesterday settlement price.
   // NOTE: Available for current trading day only.
   optional sint32 scaled_yesterday_settlement = 5;

   // Contract total volume.
   optional uint64 scaled_total_volume = 6;

   // Yesterday close price.
   // NOTE: Available for current trading day only.
   optional sint32 scaled_yesterday_close = 7;

   // Indicative open price.
   optional sint32 scaled_indicative_open = 8;

   // Indicative open volume.
   optional uint64 scaled_indicative_open_volume = 15;

   // Day index the market values are related to.
   // 0 - current trading day, -1 - yesterday's trading day, etc.
   required sint32 day_index = 9;

   // Open interest.
   optional sint64 scaled_open_interest = 10;

   // Contract tick volume.
   optional uint32 tick_volume = 11;

   // Settlement price.
   optional sint32 scaled_settlement = 12;

   // Identifiers of fields being cleared.
   // It also specifies to clear corresponding yield values in market_yields.
   repeated uint32 cleared_fields = 13;

   // Trading date the market values belong to.
   required sint64 trade_date = 14;

   // Session index the market values are related to.
   // 0 - first session of the day, 1 - second session of the day, etc.
   optional uint32 session_index = 17;

   // Market yields.
   // Included if subscribed and the contract support yields.
   optional MarketYields market_yields = 16;
}

// Market yields of a contract.
message MarketYields
{
   // Yield corresponding to open price.
   optional double yield_of_open_price = 1;

   // Yield corresponding to high price.
   optional double yield_of_high_price = 2;

   // Yield corresponding to low price.
   optional double yield_of_low_price = 3;

   // Yield corresponding to close price.
   optional double yield_of_close_price = 4;

   // Yesterday settlement yield.
   // NOTE: Available for current trading day only.
   optional double yield_of_yesterday_settlement = 5;

   // Yesterday close yield.
   // NOTE: Available for current trading day only.
   optional double yield_of_yesterday_close = 6;

   // Indicative open yield.
   optional double yield_of_indicative_open = 7;

   // Settlement yield.
   optional double yield_of_settlement = 8;
}

// Read stored user attribute by name.
message ReadUserAttributeRequest
{
   // ID of a request and optional subscription that should be unique enough to match responses and updates with corresponding requests.
   required uint32 request_id = 1;

   // List of names of requested attributes or expressions to match.
   // Empty list means requesting of all available user attributes
   repeated string attribute_name = 2;
}

// Result with requested attributes.
message ReadUserAttributeResult
{
   // Corresponding request ID
   required uint32 request_id = 1;

   // Result code.
   enum ResultCode
   {
      // success codes
      SUCCESS = 0;

      // failure codes (100+)
      FAILURE = 101;

      // The request rate limit has been violated.
      REQUEST_RATE_LIMIT_VIOLATION = 102;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // List of requested attributes.
   repeated UserAttribute user_attribute = 3;

   // Optional failure details.
   optional string text_message = 4;
}

// Modify or delete user attributes.
message ModifyUserAttributeRequest
{
   // ID of a request that should be unique enough to match responses with corresponding requests.
   required uint32 request_id = 1;

   // List of attributes to modify.
   repeated UserAttribute user_attribute = 2;
}

// User attributes modification result.
message ModifyUserAttributeResult
{
   // Corresponding request ID.
   required uint32 request_id = 1;

   // Result code.
   enum ResultCode
   {
      // success codes
      SUCCESS = 0;

      // failure codes (100+)
      FAILURE = 101;

      // The request rate limit has been violated.
      REQUEST_RATE_LIMIT_VIOLATION = 102;

      // The limit of storage space has been violated.
      STORAGE_SPACE_LIMIT_VIOLATION = 103;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // Optional failure details.
   optional string text_message = 3;
}

// Historical orders request.
message HistoricalOrdersRequest
{
   // Only orders from specified business date (inclusively) is to be returned (date only value in time format).
   required sint64 from_date = 1;

   // Only orders till specified business date (inclusively) is to be returned (date only value in time format).
   // Current business day if the field is omitted.
   optional sint64 to_date = 2;

   // Filter orders by account. Not specifying any account means all accounts of the user.
   repeated sint32 account_id = 3;
}

// Response for historical orders request.
message HistoricalOrdersReport
{
   // List of order statuses matching historical order filter.
   repeated OrderStatus order_status = 1;
}

// Parameters for Time and Sales request.
message TimeAndSalesParameters
{
   // contract id for Time and Sales request.
   required uint32 contract_id = 1;

   // Level or requested Time and Sales data.
   enum Level
   {
      // Get trades with volumes and settlement quotes.
      TRADES = 1;

      // Get trades, settlement and best ask & bid quotes with volumes.
      TRADES_BBA_VOLUMES = 3;
   }
   // This field is associated with Level enum type.
   required uint32 level = 2;

   // Time and Sales period time to start from.
   required sint64 from_utc_time = 3;

   // Optional Time and Sales period finish time.
   // Current server time is used if it is not specified.
   optional sint64 to_utc_time = 4;
}


// Time and sales request (30 days history limit).
message TimeAndSalesRequest
{
   // Request ID, should be unique among currently processed requests.
   required uint32 request_id = 1;

   // parameters of a request, ignored for a DROP operation.
   optional TimeAndSalesParameters time_and_sales_parameters = 2;

   // Type of request.
   enum RequestType
   {
      // Request.
      GET = 1;

      // Drop request.
      DROP = 3;
   }
   // This field is associated with RequestType enum type. GET operation is processed by default.
   optional uint32 request_type = 3;
}

message TimeAndSalesReport
{
   // ID of a corresponding request.
   required uint32 request_id = 1;

   // Result code.
   enum ResultCode
   {
      /// success codes  (0 - 99)
      // Request is processed successfully.
      SUCCESS = 0;

      // Delayed request is dropped by a client.
      DROPPED = 2;

      // Request processing status that indicates that currently processing is impossible because of communication issues.
      // NOTE: Clients should not resend requests in this case, the server will restore processing with
      // sending SUCCESS status once communication issues are resolved.
      // If client is not interested in this request any longer it should send DROP request.
      DISCONNECTED = 4;

      /// failure codes (100+)
      // General failure.
      FAILURE = 101;

      // The user is not allowed to access this instrument data.
      ACCESS_DENIED = 103;

      // Requested information is not found.
      NOT_FOUND = 104;

      // Requested data is outside of allowed range.
      OUTSIDE_ALLOWED_RANGE = 105;

      // The limit of the active historical requests has been violated.
      ACTIVE_REQUESTS_LIMIT_VIOLATION = 106;

      // The request rate limit has been violated.
      REQUEST_RATE_LIMIT_VIOLATION = 107;

      // T&S request is not supported for specified contract.
      NOT_SUPPORTED = 110;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // List of the requested Time and Sales as quotes.
   // Note that in order to simplify linking of T&S with real time quotes by a client server will atomically include
   // all quotes with the same time-stamp into T&S without splitting the group.
   repeated Quote quote = 3;

   // Time up to which the quotes were included into this report,
   // if there were several with the same time-stamp equal to this time then all are included into the report (UTC).
   // This time is set only for 'up-to-current' requests.
   optional int64 up_to_utc_time = 4;

   // True means that requested data is complete at the moment, false means more report messages are expected for completeness.
   optional bool is_report_complete = 5 [default = true];

   // Optional failure details.
   optional string text_message = 6;

   // Request contains dates partially outside of allowed historical data depth.
   optional bool truncated = 7;
}

// Continuation parameters for TimeBarRequest.
message ContinuationParameters
{
   enum ContinuationType
   {
      // Rollover with trading activity (corresponds with ContractMetadata.is_most_active).
      ACTIVE = 1;
   }

   // This field is associated with ContinuationType enum type.
   required uint32 continuation_type = 1;

   // Equalize closes (opens for bonds).
   optional bool equalize = 2 [default = false];
}

// Placeholder message of bar building tick type enumeration (some libraries do not support enumerations outside of messages)
message BarBuildingTick
{
   enum Type
   {
      // Bid
      BID = 1;

      // Ask
      ASK = 2;

      // Trade
      TRADE = 3;

      // Settlement
      SETTLEMENT = 4;
   }
}

// Parameters of a time bar request.
message TimeBarParameters
{
   // Contract id for a bar request.
   required uint32 contract_id = 1;

   // Bar unit type.
   enum BarUnit
   {
      /// Multi-day bars (3 year history limit).

      // yearly bars
      YEAR = 1;

      // semi-annual bars
      SEMI_ANNUAL = 2;

      // quarterly bars
      QUARTER = 3;

      // monthly bars
      MONTH = 4;

      // weekly bars
      WEEK = 5;

      // daily bars
      DAY = 6;

      /// Intra-day bars (3 month history limit).

      // hourly bars
      HOUR = 7;

      // minute bars
      MIN = 8;

   }
   // This field is associated with BarUnit enum type.
   required uint32 bar_unit = 2;

   // Number of units per a single bar for Intra-day bars (must be within 24 hours period).
   optional uint32 unit_number = 3;

   // Bars period time to start from.
   required sint64 from_utc_time = 4;

   // Optional bars period finish time.
   // Current server time is used if it is not specified.
   optional sint64 to_utc_time = 5;

   // Defines content of the close_price and settlement_price fields in TimeBar.
   // close_price is set to last price if the use_settlements is false or omitted, settlement_price is omitted.
   // settlement_price is set to trade date's settlement price (or omitted for today's bar, if contract did not yet settle) if the use_settlements is true, close_price is omitted.
   // Note: can be 'true' for requests with bar_unit equal only to DAY, otherwise request is rejected.
   optional bool use_settlements = 6;

   // Continuation parameters.
   optional ContinuationParameters continuation_parameters = 7;

   // List of tick types to be used in bar building.
   // This field is associated with BarBuildingTick.Type enum type.
   // When list is empty, commodity default tick types are used.
   // Note: can be non-empty for intra-day bar requests only, otherwise request is rejected.
   // Note: SETTLEMENT tick type can only be used in combination with other type(s), otherwise request is rejected.
   repeated uint32 tick_types = 8;
}

// Request for time bars with optional subscription.
// In case of subscription updates are sent when a bar opens, closes or when it is corrected. Corrected bars are sent even
// if they are outside of requested time bounds. Range can be expanded with another request if needed.
// Bar also is updated upon expiration the update interval (1 second for Intra-day bars or 1 minute for Inter-day bars), if changed.
message TimeBarRequest
{
   // request or subscription ID
   required uint32 request_id = 1;

   // parameters of a request, ignored for a DROP operation.
   optional TimeBarParameters time_bar_parameters = 2;

   // Type of a bar request.
   enum RequestType
   {
      // Request bars without subscription.
      GET = 1;

      // Request bars with subscription for updates.
      // Note: to_utc_time parameter must not be specified to subscribe.
      SUBSCRIBE = 2;

      // Drop request if server has not completed it yet and/or unsubscribe if already subscribed for updates.
      DROP = 3;
   }
   // This field is associated with RequestType enum type. GET operation is processed by default.
   optional uint32 request_type = 3;
}

// Continuation segment
message ContinuationSegment
{
   // Symbol in CQG dialect for the continuation segment
   // populated regardless of the client dialect used
   optional string cqg_symbol = 1;
}

// Time bar.
message TimeBar
{
   // Bar start time (UTC).
   required sint64 bar_utc_time = 1;

   // Open price.
   optional sint32 scaled_open_price = 2;

   // High price.
   optional sint32 scaled_high_price = 3;

   // Low price.
   optional sint32 scaled_low_price = 4;

   // Close or last price (if the bar is not closed yet).
   // It is omitted if the TimeBarParameters.use_settlements is true.
   optional sint32 scaled_close_price = 5;

   // Bar volume.
   optional uint64 scaled_volume = 6;

   // Trade date (in time format), it is set only for the first bar in a requested period
   // and for each first bar of the following trade dates for intra-day bars. Trade date of the bar first day for multi-day bars.
   optional sint64 trade_date = 7;

   // Commodity volume where available, for multi-day bars only.
   optional uint64 scaled_commodity_volume = 8;

   // Open interest, for multi-day bars only.
   optional uint64 scaled_open_interest = 9;

   // Commodity open interest, for multi-day bars only.
   optional uint64 scaled_commodity_open_interest = 10;

   // Settlement price, for daily bars only.
   // It is omitted if the TimeBarParameters.use_settlements is false or omitted.
   optional sint32 scaled_settlement_price = 11;

   // Tick volume.
   optional uint64 tick_volume = 12;

   // Commodity tick volume where available, for multi-day bars only.
   optional uint64 commodity_tick_volume = 13;

   // Continuation segment the bar belongs to, it is set only for the first bar
   // and for each first bar from the next continuation segment
   // Used only for continuation bars with MONTH and smaller BarUnit
   optional ContinuationSegment continuation_segment = 14;
}

// Placeholder message of bar report status code enumeration (some libraries do not support enumerations outside of messages)
message BarReportStatus
{
   enum Code
   {
      /// success codes  (0 - 99)
      // Request is processed without subscription (subscription was not requested).
      SUCCESS = 0;

      // Request is processed and subscription is established or restored after disconnection.
      // Data can be resent as a result of the restored subscription.
      SUBSCRIBED = 1;

      // Subscription or delayed request is dropped by a client.
      DROPPED = 2;

      // Unsolicited information update because of subscription.
      UPDATE = 3;

      // Subscription or request processing status that indicates that currently processing is impossible because of communication issues.
      // NOTE: Clients should not resubscribe or resend requests in this case, the server will restore processing with
      // sending SUCCESS or SUBSCRIBED status once communication issues are resolved.
      // If client is not interested in this request or subscription any longer it should send DROP request.
      DISCONNECTED = 4;

      // Bars are invalidated for specified time range due to data correction.
      // Re-request historical bars and/or re-subscribe to bar updates to receive valid bar data.
      // NOTE: Subscription is not dropped.
      INVALIDATED = 5;

      /// failure codes (100+), subscription (if any) is dropped in case of failure.
      // General failure.
      FAILURE = 101;

      // The user is not allowed to access this data.
      ACCESS_DENIED = 103;

      // Requested information is not found.
      NOT_FOUND = 104;

      // Requested data is outside of allowed range.
      OUTSIDE_ALLOWED_RANGE = 105;

      // Parameters of a bar request are invalid.
      INVALID_PARAMS = 106;

      // The limit of active requests has been violated.
      ACTIVE_REQUESTS_LIMIT_VIOLATION = 107;

      // The limit of simultaneous historical subscriptions has been violated.
      SUBSCRIPTION_LIMIT_VIOLATION = 108;

      // The request rate limit has been violated.
      REQUEST_RATE_LIMIT_VIOLATION = 109;

      // Bar request without subscription on updates is not supported for specified contract.
      NOT_SUPPORTED = 110;
   }
}

// Time bar data response or update.
// Each report contains set of bars. Reports related to a specific request ordered chronologically from the most recent one to the past.
// In case of subscription each report contains 'up_to_utc_time' field.
// Warning: bar updates are not synchronized with real time data so a real time quote that is included into
// a bar might be received either before or after the bar update, use time of a quote for possible real-time bar updates.
message TimeBarReport
{
   // ID of a corresponding request or subscription.
   required uint32 request_id = 1;

   // This field is associated with BarReportStatus.Code enum type.
   required uint32 status_code = 2;

   // List of time bars.
   repeated TimeBar time_bar = 3;

   // Time up to which the quotes were included into bars,
   // if there were several with the same time-stamp equal to this time then all are included into the last bar (UTC).
   // This time is set for 'up-to-current' bar requests and bar updates.
   optional int64 up_to_utc_time = 4;

   // True means that requested data is complete at the moment, false means more report messages are expected for completeness.
   optional bool is_report_complete = 5 [default = true];

   // Optional failure details.
   optional string text_message = 6 [deprecated = true];

   // Request contains dates partially outside of allowed historical data depth.
   optional bool truncated = 7;
   
   // Optional failure details.
   optional shared_1.Text details = 8;
}

// VolumeProfile request, 3 month history limit.
message VolumeProfileRequest
{
   // request ID.
   required uint32 request_id = 1;

   // Request parameters.
   optional VolumeProfileParameters volume_profile_parameters = 2;

   // Type of request action.
   enum RequestType
   {
      // Request data.
      GET = 1;
      
      // Cancel a previously issued request.
      DROP = 3;
   }

   // This field is associated with RequestType enum type.
   // GET operation is processed by default.
   optional uint32 request_type = 3;
}

// Parameters of a Volume Profile request.
message VolumeProfileParameters
{
   // Contract id for the volume profile request.
   required uint32 contract_id = 1;

   // Both of the next two fields have to be set, otherwise the request will return a failure
   // Start of the time range for volume profile to be calculated for.
   optional sint64 start_utc_time = 2;

   // Exclusive end of the time range for volume profile to be calculated for.
   optional sint64 end_utc_time = 3;
}

// VolumeProfile snapshot response.
message VolumeProfileReport
{
   // ID of the volume profile request.
   required uint32 request_id = 1;

   enum ResultCode
   {
      /// success codes  (0 - 99)
      // Request is processed successfully.
      SUCCESS = 0;

      // Delayed request is dropped by a client.
      DROPPED = 2;

      // Request processing status that indicates that currently
      // processing is impossible because of communication issues.
      // NOTE: Clients should not resend requests in this case,
      // the server will restore processing with sending SUCCESS status
      // once communication issues are resolved. If client is not interested
      // in this request any longer it should send DROP request.
      DISCONNECTED = 4;

      /// failure codes (100+)
      // General failure.
      FAILURE = 101;

      // The user is not allowed to access this instrument data.
      ACCESS_DENIED = 103;

      // Requested information is not found.
      NOT_FOUND = 104;

      // Requested data is outside of allowed range.
      OUTSIDE_ALLOWED_RANGE = 105;

      // The limit of the active historical requests has been violated.
      ACTIVE_REQUESTS_LIMIT_VIOLATION = 106;

      // VolumeProfile request is not supported for specified contract.
      NOT_SUPPORTED = 110;
   }

   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // Volume profile snapshot items.
   repeated VolumeProfileItem volume_profile_items = 3;

   // Volume profile cumulative statistics for the last quotes.
   // This field is filled only for the first chunk of the report.
   optional VolumeProfileLastQuotesCumulativeStatistics last_quotes_cumulative_statistics = 8;

   // Time up to which the quotes were included into this report,
   // if there were several with the same time-stamp equal to this time
   // then all are included into the report (UTC).
   // This time is set only for requests with time range
   // that includes the current time.
   optional int64 up_to_utc_time = 4;

   // Optional failure details.
   optional string text_message = 5;

   // Request contains dates partially outside of allowed historical data depth.
   optional bool truncated = 6;

   // True means that requested data is complete at the moment, false means more report messages are expected for completeness.
   optional bool is_report_complete = 7 [default = true];
}

// Volume profile cumulative statistics for the last quotes.
message VolumeProfileLastQuotesCumulativeStatistics
{
   // Price of the last best ask quote within Volume Profile range.
   optional sint32 scaled_last_ask_price = 1;

   // Price of the last best bid quote within Volume Profile range.
   optional sint32 scaled_last_bid_price = 2;

   // Cumulative sum of trade volumes on ask side since the last best bid or best ask price update within Volume Profile range.
   optional double scaled_ask_trade_volume = 3;

   // Cumulative sum of trade volumes on bid side since the last best bid or best ask price update within Volume Profile range.
   optional double scaled_bid_trade_volume = 4;
}

// Volume profile snapshot item.
message VolumeProfileItem
{
   // Price (unique for each volume profile snapshot reported).
   required sint32 scaled_price = 1;

   // Total volume of all trades with this price for the time range asked.
   required uint64 scaled_volume = 2;
}

// Range of bars.
message BarRange
{
   // Time of last bar.
   // Current server time is used if it is not specified.
   optional sint64 utc_time = 1;

   // Number of requested bars (back in history).
   // Note: The maximal number of bars that can be requested in one message is limited, 100000 by default.
   required uint32 count = 2;

   // Index of bar. If there is a bar with given utc_time and index,
   // the report will contain specified amount of bars preceding that bar.
   optional sint32 index = 3;
}

// Request for non-time based bars with optional subscription.
message NonTimedBarRequest
{
   // Request ID.
   required uint32 request_id = 1;

   // Type of request action.
   enum RequestType
   {
      // Request bars without subscription.
      GET = 1;

      // Request bars with subscription for updates.
      // Note: utc_time parameter of BarRange must not be specified to subscribe.
      SUBSCRIBE = 2;

      // Drop request if server has not completed it yet and/or unsubscribe if already subscribed for updates.
      DROP = 3;
   }

   // This field is associated with RequestType enum type.
   // GET operation is processed by default.
   optional uint32 request_type = 2;

   // Continuation parameters.
   optional ContinuationParameters continuation_parameters = 3;

   // Contract id.
   // Note: must be specified for GET or SUBSCRIBE types of request.
   optional uint32 contract_id = 4;

   // Specifies bar range of a request.
   // Note: must be specified for GET or SUBSCRIBE types of request.
   optional BarRange bar_range = 5;

   // List of tick types to be used in bar building.
   // This field is associated with BarBuildingTick.Type enum type.
   // When list is empty, commodity default tick types are used.
   // Note: Requests with SETTLEMENT tick type in a list are rejected.
   repeated uint32 tick_types = 10;

   /// Only one of following optional fields has to be specified.
   // Constant volume bar request parameters.
   optional ConstantVolumeBarParameters constant_volume_bar_parameters = 6;

   // P&F request parameters.
   optional PointAndFigureParameters point_and_figure_parameters = 7;

   // Renko bar request parameters.
   optional RenkoBarParameters renko_bar_parameters = 8;

   // Range bar request parameters.
   optional RangeBarParameters range_bar_parameters = 9;
}

// Parameters of a Constant Volume Bar request.
message ConstantVolumeBarParameters
{
   // Volume covered by each bar. Can take a value from 1 to 1000000000.
   required uint32 volume_level = 1;

   // Determines volume type. If false (default value) then bars are built based on exchange volume,
   // otherwise they are built based on ticks (number of inside price changes).
   // Note: WebAPI server rejects requests for contracts without actual volume data (
   //       ContractMetadata.has_exchange_volume=False).
   optional bool use_tick_volume = 2;

   // Use 0-plus and 0-minus ticks when building bars.
   // Note: applicable only to tick volume.
   optional bool use_flat_ticks = 3;
}

// Parameters of a Point and Figure request.
message PointAndFigureParameters
{
   // Specifies the number of tick units represented by each P&F. Can take a value from 1 to 1000.
   required uint32 box_size = 1;

   // Specifies the number of boxes for P&F direction reversal. Can take a value from 1 to 1000.
   required uint32 reversal = 2;
}

// Parameters of a Renko bar request.
message RenkoBarParameters
{
   // Size of single brick. Can take a value from 1 to 1000000000.
   required uint32 brick_size = 1;

   // Maximum number of null bricks that can be generated as a single brick in the case of price gaps.
   // Can take a value from 0 to 200. Default values is 0.
   optional uint32 max_null_bricks = 2;
}

// Parameters of a Range bar request.
message RangeBarParameters
{
   // Size of single range bar. Can take a value from 1 to 1000000000.
   required uint32 range_size = 1;

   // Maximum number of null range bars that can be generated as a single range bar in the case of price gaps.
   // Can take a value from 0 to 200. Default values is 0.
   optional uint32 max_null_bars = 2;
}

// Non-time based bar data response or update.
message NonTimedBarReport
{
   // ID of the request.
   required uint32 request_id = 1;

   // This field is associated with BarReportStatus.Code enum type.
   required uint32 status_code = 2;

   // Optional failure details.
   optional shared_1.Text details = 3;

   // Time from which bars are invalidated.
   optional sint64 invalidated_from_utc_time = 4;

   // Time up to which bars are invalidated.
   // If not set, bars are invalidated up to current time and bar updates are stopped for this subscription.
   optional sint64 invalidated_to_utc_time = 5;

   // Time up to which the quotes were included into bars,
   // if there were several with the same time-stamp equal to this time
   // then all are included into the report (UTC).
   // This time is set only for requests with time range that includes the current time.
   optional int64 up_to_utc_time = 6;

   // Request contains dates partially outside of allowed historical data depth.
   optional bool truncated = 7;

   // True means that requested data is complete at the moment, false means more report messages are expected for completeness.
   optional bool is_report_complete = 8 [default = true];

   /// Only one of the following repeated fields is specified.
   // Constant volume bars.
   repeated ConstantVolumeBar constant_volume_bar = 9;

   // Point and figure bars.
   repeated PointAndFigureBar point_and_figure_bar = 10;

   // Renko bars.
   repeated RenkoBar renko_bar = 11;

   // Range bars.
   repeated RangeBar range_bar = 12;
}

// Constant Volume Bar.
message ConstantVolumeBar
{
   // Bar start time (UTC), it is set only for the first bar of the following bar start times.
   optional sint64 bar_utc_time = 1;

   // Bar index. Different bars with the same bar_utc_time always have different indexes.
   // It is set only if non-zero.
   optional sint32 index = 2;

   // Trade date (in time format), it is set only for the first bar of the following trade dates.
   optional sint64 trade_date = 3;

   // Open price.
   optional sint64 scaled_open_price = 4;

   // High price.
   optional sint64 scaled_high_price = 5;

   // Low price.
   optional sint64 scaled_low_price = 6;

   // Close or last price (if the bar is not closed yet).
   optional sint64 scaled_close_price = 7;

   // Exchange volume.
   optional uint64 scaled_volume = 8;

   // Tick volume.
   optional uint64 tick_volume = 9;

   // Continuation segment the bar belongs to, it is set only for the first bar
   // and for each first bar from the next continuation segment.
   optional ContinuationSegment continuation_segment = 10;
}

// Point and Figure bar.
message PointAndFigureBar
{
   // Bar start time (UTC), it is set only for the first bar of the following bar start times.
   optional sint64 bar_utc_time = 1;

   // Bar index. Different bars with the same bar_utc_time always have different indexes.
   // It is set only if non-zero.
   optional sint32 index = 2;

   // Trade date (in time format), it is set only for the first bar of the following trade dates.
   optional sint64 trade_date = 3;

   // Open price.
   optional sint64 pf_scaled_open_price = 4;

   // High price (rounded to PF box).
   optional sint64 pf_scaled_high_price = 5;

   // Low price (rounded to PF box).
   optional sint64 pf_scaled_low_price = 6;

   // Close price.
   optional sint64 pf_scaled_close_price = 7;

   // High price (not rounded to PF box).
   optional sint64 scaled_high_price = 8;

   // Low price (not rounded to PF box).
   optional sint64 scaled_low_price = 9;

   // Exchange volume.
   optional uint64 scaled_volume = 10;

   // Tick volume.
   optional uint64 tick_volume = 11;

   // True if the P&F chart is plotting an X, False if the P&F chart is plotting an O.
   optional bool up = 12;

   // Continuation segment the bar belongs to, it is set only for the first bar
   // and for each first bar from the next continuation segment.
   optional ContinuationSegment continuation_segment = 13;
}

// Renko bar.
message RenkoBar
{
   // Bar start time (UTC), it is set only for the first bar of the following bar start times.
   optional sint64 bar_utc_time = 1;

   // Bar index. Different bars with the same bar_utc_time always have different indexes.
   // It is set only if non-zero.
   optional sint32 index = 2;

   // Trade date (in time format), it is set only for the first bar of the following trade dates.
   optional sint64 trade_date = 3;

   // Open price.
   optional sint64 scaled_open_price = 4;

   // High price.
   optional sint64 scaled_high_price = 5;

   // Low price.
   optional sint64 scaled_low_price = 6;

   // Close or last price (if the bar is not closed yet).
   optional sint64 scaled_close_price = 7;

   // Maximum of open and close prices.
   optional sint64 scaled_renko_high_price = 8;

   // Minimum of open and close prices.
   optional sint64 scaled_renko_low_price = 9;

   // Defines how renko bar is going to be closed (up or down).
   optional bool up = 10;

   // Exchange volume.
   optional uint64 scaled_volume = 11;

   // Tick volume.
   optional uint64 tick_volume = 12;

   // If this bar is the first bar of a session.
   optional bool first_bar_of_session = 13;

   // Continuation segment the bar belongs to, it is set only for the first bar
   // and for each first bar from the next continuation segment.
   optional ContinuationSegment continuation_segment = 14;
}

// Range bar.
message RangeBar
{
   // Bar start time (UTC), it is set only for the first bar of the following bar start times.
   optional sint64 bar_utc_time = 1;

   // Bar index. Different bars with the same bar_utc_time always have different indexes.
   // It is set only if non-zero.
   optional sint32 index = 2;

   // Trade date (in time format), it is set only for the first bar of the following trade dates.
   optional sint64 trade_date = 3;

   // Open price.
   optional sint64 scaled_open_price = 4;

   // High price.
   optional sint64 scaled_high_price = 5;

   // Low price.
   optional sint64 scaled_low_price = 6;

   // Close or last price (if the bar is not closed yet).
   optional sint64 scaled_close_price = 7;

   // Exchange volume.
   optional uint64 scaled_volume = 8;

   // Tick volume.
   optional uint64 tick_volume = 9;

   // Continuation segment the bar belongs to, it is set only for the first bar
   // and for each first bar from the next continuation segment.
   optional ContinuationSegment continuation_segment = 10;
}
